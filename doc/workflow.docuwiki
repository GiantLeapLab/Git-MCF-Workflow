====== Автоматизация работы с использованием нескольких локальных конфигураций. Схема работы с тремя ветками. Workflow. Cookbooks ======

===== Зачем это надо =====

Практически в любом проекте нужно настроить, как минимум, одну конфигурацию для разработчика, которая отличается от конфигурации заказчика. Например, это и настройки базы, и настройки хоста, и пути к библиотекам, и специфичные файлы IDE и т.п. Также это необходимо, чтобы помочь нескольким разработчикам иметь одинаковую конфигурационную среду.

Все это не сложно настроить, но сразу возникнет проблема, как отделять общий код от локальной конфигурации при каждой синхронизации с внешним хранилищем кода. И тем более не допустить ошибок и не сломать код на production.

В интернете есть много решений, очень популярная техника Git Workflow:
  * http://nvie.com/posts/a-successful-git-branching-model/
  * https://www.atlassian.com/git/tutorials/comparing-workflows/centralized-workflow
  * http://habrahabr.ru/post/60030/

Но они либо для больших групп разработчиков, либо имеют некоторые недостатки, которые делают неудобными их применение.

Последняя версия [[https://github.com/wellic/myworkflow|конфигурационного файла]], который описывает данный процесс

===== 3-branch workflow Master-Cfg-Fix (MCF) =====

Для работы c данной схемой используется 3 веточная схема: master-cfg-fix (MCF).

По умолчанию ветки (бранчи), имеют названия (но можно у себя назвать как удобно, главное выдержать суть содержания:
  - master — основная общая ветка с production настройками; Важно помнить, что работать на это ветке нельзя, т.к. эта ветка должно точно соответствовать тому, что находится в удаленном хранилище, может использоваться при работе, где не нужно специальное локальное окружение.
  - cfg — ветка локальной конфигурации, наследуется от мастер и имеет свои особенности. Ветка предназначена для настройки и внесения изменений необходимых для локальной работы разработчика (конфигурационные файлы, различные настройки и т.п.). Данная ветка также не используется для работы.
  - fix — ветка разработки, наследуется от cfg. В ней ведется разработка. По окончанию работ изменения, сделанные в ней, переносятся в ветку master и в удаленное хранилище с помощью команды upload.

Для синхронизации  информацией между ветками и внешним репозиторием после окончания работ на ветке fix было построено 2 команды, которые выполняют набор необходимых действий: 
  - подтянуть изменения из внешнего репозитория, т.к. во время работы могли произойти изменения, т.е. обновить ветку master;
  - перенести эти изменения на ветки cfg и fix;
  - применить изменения с ветки fix на ветку master, исключая изменения в ветке cfg;
  - отправить в репозиторий обновленную ветку master;
  - отправить в репозиторий копию ветки ветки cfg;
  - на всякий случай применить пункты 1 и 2, если за время синхронизации появились новые изменения.

Пункты 1 и 2 выполняет пользовательская команда git update. Эта команда синхронизирует локальные ветки master-cfg-fix (MCF) с текущим состоянием во внешенем репозитории. 

Весь цикл, а именно пункты 1-6, выполняет команда git upload.

На рисунке показан процесс синхронизации между удаленным репозиторием и локальным хранилищем до и после применения команды upload.

{{ :techdocs:cvs:git:git_workflow_upload.png|выполнение команды upload }}

Для упрощения на рисунке не показано, что в удаленном хранилище создается последний временная ветка с последним коммитом из локальной ветки cfg.

Вывод: для работы с внешним репозиторием достаточно одной (upload), максимум двух команд (update+upload). Преимущество - вся ручная работа безошибочно выполняется в автоматическом режиме, при этом выполняется достаточно большое количество операций. Практически в 99% случаев все проходит без конфликтов, и занимает несколько секунд.  Также данные команды могут использоваться и для схемы работы, когда не нужно специальное рабочее окружения. Ветка cfg создается для совместимости и не используется, и все команды используются для синхронизации как было описано выше.

===== Пример реальной задачи =====
В качестве примера возьмем CMS PrestaShop. Эту CMS мы используем в своих проектах, но также, вносим правки в нее, т.е. являемся для нее контрибьютерами.

Для этого мы используем 3 репозитория:
  - presta - источник оригинального кода Prestashop
  - gll - форк оригинала PrestaShop, необходим для контрибуции
  - origin - наш репозиторий для текущего проекта

Стандартные задачи, которые нужно выполнять регулярно:
  * загружать обновления с presta;
  * синхронизировать presta c gll;
  * обновление локальной разработки origin обновлениями c presta;
  * вносить замеченные ошибки и улучшения в PrectsShop;
  * решение текущей задачи с PrestaShop;
  * бекап копии конфигурации для локальной разработки.


==== Предварительная настройка ====

Настройка репозиториев для работы:<code>
#origin - our project
git clone git@git.giantleaplab.com:client-projects/OurProject

# presta - dev branch
git remote add presta https://github.com/PrestaShop/PrestaShop.git

# gll - fork presta
git remote add gll git@github.com:GiantLeapLab/PrestaShop.git
</code>

==== Настройка веток разработки ====

Для работы используется несколько веток. Настроим окружение.
  - '1.6' - ветка из presta, содержит последние изменения Prestashop. Эта же ветка используется в gll для дальнейшей контрибуции<code>
git fetch presta 1.6
git checkout 1.6
</code>
  - 'work' - ветка в origin, порождается от 1.6, содержит наши разработки<code>
git checkout -b work
</code>
  - 'cfg' - локальная ветка, порождается от work, содержит настройки локальной конфигурации для разработки<code>
git checkout -b cfg
</code>
  - 'fix' - локальная ветка, порождается от cfg, в ней ведется разработка<code>
git checkout -b fix
</code>
  - удаляем локальную ветку master, т.к. мы ее использовать не будем и чтобы она нас не запутывала<code>
git branch -D master
</code>

==== Стандартная разработка ====
Считаем, что все синхронизировано, все ветки созданы. 

=== Работа ===

Работы выполняем на ветке fix:<code>
git checkout fix
...
git commit -m 'Issue 1'
...
git commit -m 'Issue 2'
...
git commit -m 'Issue 3'
</code>

=== Отправка результатов работы ===

Теперь нам нужно все перенести на ветку work и отправить в хранилище. Но за время нашей работы в presta/1.6 или в origin/work могли внести изменения. Поэтому нужно сделать достаточно много этапов для внесения новых изменений по веткам.
  * Загрузить новые обновления, которые могли сделать коллеги из origin/work в work:<code>
git fetch origin work
git checkout work
git merge origin/work
</code>
  * Загрузить новые обновления из presta/1.6 в ветки 1.6 и work:<code>
git fetch presta 1.6
git checkout 1.6
git merge presta 1.6
git push gll 1.6:1.6
git checkout work
git merge 1.6 --no-edit
</code>
  * Восстановить связи cfg и fix c work после обновления:<code>
git checkout work
git rebase work cfg
git rebase cfg fix
</code>
  * Залить изменения из ветки fix в ветку work, исключая настройки локальной конфигурации cfg:<code>
git checkout fix
git rebase --onto work cfg fix
git checkout work
git rebase fix work
git rebase work cfg
git rebase cfg fix
</code>
  * Отправить изменения в origin и сделать бекап локальной конфигурации в origin/cfg_backup:<code>
git push origin work:work
git push --force origin cfg:cfg_backup
</code>

Но все действия по отправке можно заменить простой парой комманд:<code>
git upload fix cfg work presta 1.6 origin work
git push gll 1.6:1.6
</code>

=== Оптимизация отправки результатов работы ===

Чтобы не набирать в командной строке большое количество параметров, учитывая, что вместо ветки master используется ветка work, удобно в файле .git/config внести вспомогательные алиасы:<code>
[alias]
#эта команда вызывается при вызове команды update
addsync = "! f(){ \
 echo \"=  git addsync 1: git push gll 1.6:1.6\" && git push gll 1.6:1.6 \
 ;}; f"

wupdate = "! f(){ \
 fix=${1:-fix} \
 && cfg=${2:-cfg} \
 && master=${3:-work} \
 && git update $fix $cfg $master \
 && git update $fix $cfg $master presta 1.6 \
 ;}; f"

wupload = "! f(){ \
 fix=${1:-fix} \
 && cfg=${2:-cfg} \
 && master=${3:-work} \
 && git upload $fix $cfg $master presta 1.6 origin $master \
 ;}; f"
</code>

И тогда выкладывание своих правок будет всего лишь одной коммандой:<code>
git wupload
</code>
==== Контрибуция ====
После исправления ошибки, достаточно отправить в репозиторий gll ветку, и уже на сайте гитхаб сделать pull-request:<code>
git checkout cfg
git checkout -b fix_issue_presta
.....
git commit -m 'Fixed issue in prestashop'
git push gll fix_issue_presta:fix_issue_presta
</code>

Когда правку примут, то нужно удалить лишние ветки:<code>
git checkout cfg
git branch -D fix_issue_presta
git push gll :fix_issue_presta
git remote prune gll
</code>

===== Примеры задач и схемы их решения (Cookbooks) =====

Считаем, что все макросы для работы добавлены в ~/.gitconfig и настроены имя, почта, ник. 

==== Задача: Создание структуры MCF ====

  * Создание веток cfg и fix:<code>
git checkout master
git checkout -b cfg
git checkout -b fix
</code>


==== Задача: Настройка локальной конфигурации ====

  - настройка<code>
git checkout cfg
... edit and setup config files ...
git status 
git add .
git commit  -m 'your message'
... настраиваем столько сколько нужно разные настройки, несколько комитов …
</code>
  - применение новых настроек в ветке<code>
git rb cfg fix</code>

==== Задача: Ведение разработки на дефолтной ветке fix ====

  - создать структуру MCF<code>
git checkout cfg
git checkout -b fix
</code>
  - исправляем ошибки, делаем много комитов на ветке newfix:<code>
... edit files …
git status 
git add .
git commit  -m 'your message'
... повторяем столько сколько нужно ...
</code>
  - отправляем правки в репозиторий<code>
git upload
</code>

==== Задача: ведение разработки на кастомной ветке newfix, co специальной конфигурацией cfg_special ====
  - создать структуру MCF для кастомной ветки newfix<code>
git checkout master
git checkout -b cfg_special
git checkout -b newfix
</code>
  - Исправляем ошибки, делаем много комитов на ветке newfix, как обычно<code>
... edit files …
git status 
git add .
git commit  -m 'your message'
... повторяем столько сколько нужно ...
</code>
  - отправляем правки<code>
git upload newfix cfg_special
</code>

==== Задача: Отправка своих изменений из ветки fix в удаленный репозиторий (полный цикл с тестированием) ====
  - Проверка новых внешних изменений (ветки master,cfg,fix)<code>
git update
</code>
  - Тестируем с полученными новыми внешними изменениями, если все ок -  загружаем свои правки из дефолтных веток в удаленный репозиторий<code>
git upload
</code>

==== Задача: Загрузка локальных изменений на локальную ветку master и на внешний ресурс ====
  * upload<code>
git upload [ fixNameBranch [ cfgNameBranch [ masterNameBranc ] ] ]
git upload fix234 cfg_nginx 
</code>

==== Задача: Загрузка внешних изменений в локальные ветки ====

  * update<code>
git update [ fixNameBranch [ cfgNameBranch [ masterNameBranc ] ] ]
git update fix234 
</code>

===== Вывод =====

Данная система команд позволяет с помощью предложенной схемы:
  * автоматическое обновление исходников в рабочих ветках;
  * автоматическое обновление исходников в удаленном хранилище;
  * поддерживать линейную схему истории;
  * делается бекап локального конфига на удаленный сервер;
  * для одного проекта можно использовать несколько локальных конфигов окружения;
  * при автоматических обновлениях все шаги документируются;
  * позволяет в группе проводить единую схему работы;
  * уменьшения количества ошибок за счет автоматизации процесса;
  * может использоваться при работе, где не нужно специальное локальное окружение.

===== TODO =====

Необходимо будет доделать работу не только с сервером origin, но и дать возможность указывать другие удаленные хранилища. Например, чтобы обновления брались с одного сервера, а изменения писались на другой внешний сервер.

===== Дополнение =====

==== Исходники ====

https://github.com/wellic/myworkflow

==== Настройка .gitconfig ====

Добавьте с помощью текстового редактора в свой ~/.gitconfig необходимые команды из [[https://github.com/wellic/myworkflow/blob/master/.gitconfig_sample|.gitconfig_sample]].

В [[https://github.com/wellic/myworkflow/blob/master/.gitconfig_sample|.gitconfig_sample]] кроме описанных выше макрокоманд upload, update, также представлены другие полезные команды, которые помогают в повседневной работе с гит. 