====== Автоматизация работы с использованием нескольких локальных конфигураций. Схема работы с тремя ветками. Workflow. Cookbooks ======

===== Зачем это надо =====

Практически в любом проекте нужно настроить, как минимум, одну конфигурацию для разработчика, которая отличается от конфигурации заказчика. Например, это и настройки базы, и настройки хоста, и пути к библиотекам, и специфичные файлы IDE и т.п. Также это необходимо, чтобы помочь нескольким разработчикам иметь одинаковую конфигурационную среду.

Все это не сложно настроить, но сразу возникнет проблема, как отделять общий код от локальной конфигурации при каждой синхронизации с внешним хранилищем кода. И тем более не допустить ошибок и не сломать код на production.

В интернете есть много решений, очень популярная техника Git Workflow:
  * http://nvie.com/posts/a-successful-git-branching-model/
  * https://www.atlassian.com/git/tutorials/comparing-workflows/centralized-workflow
  * http://habrahabr.ru/post/60030/

Но они либо для больших групп разработчиков, либо имеют некоторые недостатки, которые делают неудобными их применение.

Последняя версия [[https://github.com/wellic/myworkflow|конфигурационного файла]], который описывает данный процесс

===== 3-branch workflow Master-Cfg-Fix (MCF) =====

Для работы c данной схемой используется 3 веточная схема: master-cfg-fix (MCF).

По умолчанию ветки (бранчи), имеют названия (но можно у себя назвать как удобно, главное выдержать суть содержания:
  - master — основная общая ветка с production настройками; Важно помнить, что работать на это ветке нельзя, т.к. эта ветка должно точно соответствовать тому, что находится в удаленном хранилище.
  - cfg — ветка локальной конфигурации, наследуется от мастер и имеет свои особенности. Ветка предназначена для настройки и внесения изменений необходимых для локальной работы разработчика (конфигурационные файлы, различные настройки и т.п.). Данная ветка также не используется для работы.
  - fix — ветка разработки, наследуется от cfg. В ней ведется разработка. По окончанию работ изменения, сделанные в ней, переносятся в ветку master и в удаленное хранилище с помощью команды upload.

Для синхронизации  информацией между ветками и внешним репозиторием после окончания работ на ветке fix было построено 2 команды, которые выполняют набор необходимых действий: 
  - подтянуть изменения из внешнего репозитория, т.к. во время работы могли произойти изменения, т.е. обновить ветку master;
  - перенести эти изменения на ветки cfg и fix;
  - применить изменения с ветки fix на ветку master, исключая изменения в ветке cfg;
  - отправить в репозиторий обновленную ветку master;
  - отправить в репозиторий копию ветки ветки cfg;
  - на всякий случай применить пункты 1 и 2, если за время синхронизации появились новые изменения.

Пункты 1 и 2 выполняет пользовательская команда git update. Эта команда синхронизирует локальные ветки master-cfg-fix (MCF) с текущим состоянием во внешенем репозитории. 

Весь цикл, а именно пункты 1-6, выполняет команда git upload.

На рисунке показан процесс синхронизации между удаленным репозиторием и локальным хранилищем до и после применения команды upload.

{{ :techdocs:cvs:git:git_workflow_upload.png|выполнение команды upload }}

Для упрощения на рисунке не показано, что в удаленном хранилище создается последний временная ветка с последним коммитом из локальной ветки cfg.

Вывод: для работы с внешним репозиторием достаточно одной (upload), максимум двух команд (update+upload). Преимущество - вся ручная работа безошибочно выполняется в автоматическом режиме, при этом выполняется достаточно большое количество операций. Практически в 99% случаев все проходит без конфликтов, и занимает несколько секунд. 

===== Примеры задач и схемы их решения (Cookbooks) =====

Считаем, что все макросы для работы добавлены в ~/.gitconfig и настроены имя, почта, ник. 

==== Задача: Создание структуры MCF ====

  * Создание веток cfg и fix:<code>
git checkout master
git checkout -b cfg
git checkout -b fix
</code>


==== Задача: Настройка локальной конфигурации ====

  - настройка<code>
git checkout cfg
... edit and setup config files ...
git status 
git add .
git commit  -m 'your message'
... настраиваем столько сколько нужно разные настройки, несколько комитов …
</code>
  - применение новых настроек в ветке<code>
git rb cfg fix</code>

==== Задача: Ведение разработки на дефолтной ветке fix ====

  - создать структуру MCF<code>
git checkout cfg
git checkout -b fix
</code>
  - исправляем ошибки, делаем много комитов на ветке newfix:<code>
... edit files …
git status 
git add .
git commit  -m 'your message'
... повторяем столько сколько нужно ...
</code>
  - отправляем правки в репозиторий<code>
git upload
</code>

==== Задача: ведение разработки на кастомной ветке newfix, co специальной конфигурацией cfg_special ====
  - создать структуру MCF для кастомной ветки newfix<code>
git checkout master
git checkout -b cfg_special
git checkout -b newfix
</code>
  - Исправляем ошибки, делаем много комитов на ветке newfix, как обычно<code>
... edit files …
git status 
git add .
git commit  -m 'your message'
... повторяем столько сколько нужно ...
</code>
  - отправляем правки<code>
git upload newfix cfg_special
</code>

==== Задача: Отправка своих изменений из ветки fix в удаленный репозиторий (полный цикл с тестированием) ====
  - Проверка новых внешних изменений (ветки master,cfg,fix)<code>
git update
</code>
  - Тестируем с полученными новыми внешними изменениями, если все ок -  загружаем свои правки из дефолтных веток в удаленный репозиторий<code>
git upload
</code>

==== Задача: Загрузка локальных изменений на локальную ветку master и на внешний ресурс ====
  * upload<code>
git upload [ fixNameBranch [ cfgNameBranch [ masterNameBranc ] ] ]
git upload fix234 cfg_nginx 
</code>

==== Задача: Загрузка внешних изменений в локальные ветки ====

  * update<code>
git update [ fixNameBranch [ cfgNameBranch [ masterNameBranc ] ] ]
git update fix234 
</code>

===== Вывод =====

Данная система команд позволяет с помощью предложенной схемы:
  * автоматическое обновление исходников в рабочих ветках;
  * автоматическое обновление исходников в удаленном хранилище;
  * поддерживать линейную схему истории;
  * делается бекап локального конфига на удаленный сервер;
  * для одного проекта можно использовать несколько локальных конфигов окружения;
  * при автоматических обновлениях все шаги документируются;
  * позволяет в группе проводить единую схему работы;
  * уменьшения количества ошибок за счет автоматизации процесса.

===== TODO =====

Необходимо будет доделать работу не только с сервером origin, но и дать возможность указывать другие удаленные хранилища. Например, чтобы обновления брались с одного сервера, а изменения писались на другой внешний сервер.

===== Дополнение =====

==== Исходники ====

https://github.com/wellic/myworkflow

==== Настройка .gitconfig ====

Ниже представлен пример файла ~/.gitconfig, в котором кроме описанных выше макрокоманд upload, update, а также представлены другие полезные команды, которые помогают в повседневной работе с гит. 

Добавьте с помощью текстового редактора в свой ~/.gitconfig

<code>

#customize your
#   user.name
#   user.email
#   alias.mynikname
[user]
#!!! Customize name
  name = your_name
#!!! Customize email
  email = your_mail
[alias]
#!!! Customize nikname Только одно слово 
  mynikname = "! f() {          \
    nikname='your_nikname'      \
    ;echo $nikname              \
  ;}; f"

  myname = "! echo $(git config user.name | tr -d '\n')"
  myallname = "! echo $(git mynikname)'|'$(git myname)"

#Check labels in sources. Useful look for nikname, f.e. in comments 
  mycheck = "! f() {                  \
    allname=$(git mynik);             \
    echo Find nikname in sources $allname;                    \
    git grep -nEe \"${allname}\"      \
  ;}; f "

  st = status
  co = checkout
  ci = commit
  amend = commit --amend -C HEAD
  br = branch
  rb = rebase
  rbi = rebase -i
  ch = cherry-pick
  unstage = ! git reset HEAD -- $@ 

  hist = log --pretty=format:\"%C(green)%h %C(yellow)%ad%C(cyan)%d%Creset | %s %C(black bold)[%an]%Creset \" --graph --date=short --decorate
  hist2 = log --pretty=format:\"%C(green)%h %C(yellow)%ad%Creset | %s %C(black bold)[%an]%Creset \" --graph --date=short --decorate
  last = log --pretty=format:\"%C(green)%h %C(yellow)%ad%C(cyan)%d%Creset | %s %C(black bold)[%an]%Creset \" --graph --date=short --decorate -20
  sshow = show --stat --pretty=format:\"%C(green)%h %C(yellow)%ad%C(cyan)%d%Creset | %s %C(black bold)[%an]%Creset \" --graph --date=short --decorate --no-notes
  visual = !gitk &

# see gitignore: git gi list
  gi = "!gi() { curl -L -s https://www.gitignore.io/api/$@ ;}; gi"

#Show log for current user sorted by date
  mylogsort = "! f() { \
    git mylog $@ | sort --key=3,3 -r \
  ;}; f $@"

  mylog = "! f() { \
    allname=$(git myallname); \
    name=$(git myname); \
    nik=$(git mynikname); \
    echo Log of user \"'$allname'\" sorted by date; \
    git hist2 $@ | grep -i -E \"${allname}\" | sed \"s/\\[${name}\\]//i\" | sed \"s/\\[${nik}\\]//i\" \
  ;}; f $@"

  df = diff
  df0 = diff -U0
  dfc = diff --cached
  lg = log -p
  lol = log --graph --decorate --pretty=oneline --abbrev-commit
  lola = log --graph --decorate --pretty=oneline --abbrev-commit --all
  ls = ls-files

# Show files ignored by git:
  ign = ls-files -o -i --exclude-standard

# To see the list of the ignored files.
  ignored = !git ls-files -v | grep ^[a-z]

# temporarily ignoring file
  ignore = update-index --assume-unchanged
  unignore = update-index --no-assume-unchanged
  merged = branch --merged
  unmerged = branch --no-merged

fsckclear = "! f(){ \
    echo "= git fsck"                                             && git fsck \
    && echo "= git reflog expire --expire-unreachable=now --all"  && git reflog expire --expire-unreachable=now --all \
    && echo "= git gc --prune prunefsck"                          && git gc --prune=now \
    && echo "= git fsck"                                          && git fsck ;}; f"

##########################
### my worlflow useful
##########################

pushall      = ! echo "=  pushall"         && git push --all origin
pushallforce = ! echo "=  pushallforce"    && git push --all --force origin

copy2tmp = "! f(){ \
 user=$(git mynikname) \
 && tmpbranch=tmp_${user} \
 && cbr=$(git rev-parse --abbrev-ref HEAD) \
 && echo "=   copy2tmp" \
 && echo "==  copy2tmp 1: git add ."                                      && git add . \
 && echo "==  copy2tmp 2: git ci -am 'tmp_'${cbr}_$(date +%y%m%d_%H%M%S)" && git ci -am 'tmp_'${cbr}_$(date +%y%m%d_%H%M%S) \
 && echo "==  copy2tmp 3: git push -f origin $cbr:$tmpbranch"             && git push -f origin $cbr:$tmpbranch \
 && echo "==  copy2tmp 4: git reset HEAD~1"                               && git reset HEAD~1 \
 && echo '---------------' \
 && git st ;}; f"

backupcfg = "! f(){ \
 user=$(git mynikname) \
 && cfg=${1:-cfg} \
 && tmpbranch=${cfg}_${user} \
 && cbr=cfg \
 && echo "=   backupcfg" \
 && echo "==  backupcfg 1: git push -f origin $cbr:$tmpbranch" && git push -f origin $cbr:$tmpbranch \
 && echo '---------------' \
 && git st ;}; f"


# Загрузить свои изменения в ветку master из ветки fix, исключая коммиты ветки cfg. Стать на ветку мастер.
load = "! f(){ \
 fix=${1:-fix} && cfg=${2:-cfg} && master=${3:-master} \
 && echo "=  load $fix $cfg $master " \
 && echo "== load 1: git co $fix"                      && git co $fix \
 && echo "== load 2: git rb --onto $master $cfg $fix"  && git rb --onto $master $cfg $fix  \
 && echo "== load 3: git co $master"                   && git co $master \
 && echo "== load 4: git rebase $fix $master"          && git rebase $fix $master ;}; f"

# Обновить master из origin. Залить изменения из fix и cfg. Вернуться в fix.
update = "! f(){ \
 fix=${1:-fix} && cfg=${2:-cfg} && master=${3:-master} \
 && echo "=  update ${fix} ${cfg} ${master} " \
 && echo "== update 1: git co $master"      && git co $master  \
 && echo "== update 2: git pull --rebase"   && git pull --rebase \
 && echo "== update 3: git rb $master $cfg" && git rb $master $cfg \
 && echo "== update 4: git rb $cfg $fix"    && git rb $cfg $fix ;}; f"

# Обновить master из origin. Залить изменения из fix в master. Отправить мастер в origin. Сделать бекап cfg, Вернуться в fix.
upload = "! f(){ \
 fix=${1:-fix} && cfg=${2:-cfg} && master=${3:-master} \
 && echo "=  upload $fix $cfg $master " \
 && echo "== upload 1: "                                && git update $fix $cfg $master \
 && echo "== upload 2: "                                && git load $fix $cfg $master \
 && echo "== upload 3: git push origin $master:$master" && git push origin $master:$master \
 && echo "== upload 4: "                                && git update $fix $cfg $master \
 && echo "== upload 5: git backupcfg"                   && git backupcfg \
 && echo "== update 6: git co $fix"                     && git co $fix   \
 && echo "=====" && git last ;}; f"

</code>

