#customize your
#   user.name
#   user.email
#   user.nikname
[user]  
	name = your_name
	email = your@mail
	nikname = yournik

#####################
### Start ALIASES ###
#####################

[alias]


###########
# User info
###########

myname = "! git config user.name"
mynikname = "! git config user.nikname"
myallname = "! echo $(git myname)'\\|'$(git mynikname)"

#Check labels in sources. Useful look for nikname, f.e. in comments
mycheck = "! f() { \
 allname=$(git mynik); \
 echo Find nikname in sources $allname; \
 git grep -nEe \"${allname}\" \
;}; f "

###############
# Main commands
###############

br = branch
co = checkout
ci = commit
amend = commit --amend -C HEAD
st = status
rb = rebase
rbi = rebase -i
ch = cherry-pick
unstage = "! git reset HEAD -- $* "

# diff
df = diff
df0 = diff -U0
dfc = diff --cached
visual = !gitk --all &

# show history and log
sshow = "! f() { git --no-pager show --no-notes --stat --pretty=format:\"%C(green)%h %C(yellow)%ad%C(cyan)%d%Creset | %s %C(black bold)[%an]%Creset\" --graph --date=short --decorate $* && echo  ; }; f "
last  = "! f() { git --no-pager log  -20               --pretty=format:\"%C(green)%h %C(yellow)%ad%C(cyan)%d%Creset | %s %C(black bold)[%an]%Creset\" --graph --date=short --decorate $* && echo  ; }; f "
hist  = "! f() { git --no-pager log                    --pretty=format:\"%C(green)%h %C(yellow)%ad%C(cyan)%d%Creset | %s %C(black bold)[%an]%Creset\" --graph --date=short --decorate $* && echo  ; }; f "
hist2 = "! f() { git --no-pager log                    --pretty=format:\"%C(green)%h %C(yellow)%ad%Creset | %s %C(black bold)[%an]%Creset\"           --graph --date=short --decorate $* && echo  ; }; f "

#Show log for current user without sorte
mylog = "! f() { \
 allname=$(git myallname); \
 name=$(git myname); \
 nik=$(git mynikname); \
 echo Log of users: \"'$allname'\" \"'$name'\" \"'$nik'\"; \
 git hist2 $* --author=\"$allname\" --author=\"=$name\" --author=\"$nik\" \
;}; f "

#Show log for current user sorted by date
mylogsort = "! f() { \
 git mylog $* | sort -k 3,3 -r \
;}; f"

#################
# Useful commands
#################

cbr = rev-parse --abbrev-ref HEAD
get-current-branch = "! git cbr"

type = cat-file -t
dump = cat-file -p

# ignored
# Show files ignored by git:
ign = ls-files -o -i --exclude-standard
# to see the list of the ignored files.
ignored = !git ls-files -v | grep ^[a-z]

# temporarily ignoring file
ignore   = update-index --assume-unchanged
unignore = update-index --no-assume-unchanged

# check merged
merged   = branch --merged
unmerged = branch --no-merged

# different list and logs
ls = ls-files
lg    = "! f() { git --no-pager log -p $* && echo  ; }; f "
lol   = "! f() { git --no-pager log       --graph --decorate --pretty=oneline --abbrev-commit $*       && echo  ; }; f "
lola  = "! f() { git --no-pager log --all --graph --decorate --pretty=oneline --abbrev-commit --all $* && echo  ; }; f "

# for see gitignore: git gi list
gi = "! gi() { curl -L -s https://www.gitignore.io/api/$@ ;}; gi"

##########################
# Services commands
##########################
# Всмомогательные комманды
##########################

l-fsckclear = "! f(){ \
 git l-echo \"git fsck\"                                            && git fsck \
 && git l-echo \"git reflog expire --expire-unreachable=now --all\" && git reflog expire --expire-unreachable=now --all \
 && git l-echo \"git gc --prune prunefsck\"                         && git gc --prune=now \
 && git l-echo \"git fsck\"                                         && git fsck ;}; f"

# Показать сообщение нужным цветом и оттенком
# COLOR={0..7}
#  0-Black(Grey), 1-Red, 2-Green, 3-Brown/Orange(Yellow), 4-Blue,  5-Purple, 6-Cyan, 7-Light Gray(White)
# BRIGHT={0|1|2|4|7|9}
#  0(normal), 1(light), 2(dark), 4(underline), 7(invert) 9(cross)
l-echo = "! f() { \
 MESS=${1:-} \
 && COLOR=${2:-3} \
 && BRIGHT=${3:-1} \
 && COLOR=\"\\033[${BRIGHT};3${COLOR}m\" \
 && NOCOLOR=\"\\033[0m\" \
 && MESS=\"${COLOR}${MESS}${NOCOLOR}\" \
 && [ \"$(uname)\" = 'Linux' ]  && echo \"$MESS\" || echo -e \"$MESS\" \
;}; f"


l-echo-l0 = "! f() { \
 MESS=${1:-} \
 && COLOR=${2:-2} \
 && BRIGHT=${3:-2} \
 && git l-check-debug-level 0 \
 && git l-echo \"= $MESS\" \"$COLOR\" \"$BRIGHT\" \
 || : \
;}; f"

l-echo-l1 = "! f() { \
 MESS=${1:-} \
 && COLOR=${2:-6} \
 && BRIGHT=${3:-2} \
 && git l-check-debug-level 1 \
 && git l-echo \"== $MESS\" \"$COLOR\" \"$BRIGHT\" \
 || : \
;}; f"

# Посмотреть последние коммиты текущей ветки, если $showlog=show|on|''
# Конечная ветка: не меняется.
l-checklast = "! f(){ \
 showlog=${1:-show} \
 && [ -z \"$showlog\" -o \"$showlog\" = 'on' -o \"$showlog\" = 'show' ] && (git l-echo '--- Please check ---' 5; git last) || : \
;}; f"

# Сделать сделать быстро фейковый коммит, например, для тестов.
# Создается фейковый пустой файл.
# Конечная ветка: не меняется.
l-fakecommit ="! git l-fakecommit-default"
l-fakecommit-default ="! f(){ \
 mess=${1:-} \
 && showlog=${2:-} \
 && a=_fakefile_.$(basename $PWD).$(date +%Y%m%d_%H%M%S) \
 && [ -z \"$mess\" ] && mess=\"added $a\" || : \
 && touch \"$a\" && git add \"$a\" && git commit -m \"'Fake commit: $mess'\" \
 && git l-checklast $showlog \
;}; f"

#must be -1|0|1
# 0 - (normal mode) show l0 diagnostic message in w-*functions
# 1 - (debug mode)  show l0 and l1 diagnostic message in w-*functions
l-debug-level = ! echo 0

l-check-debug-level = "! f() { \
 level=${1:-0} \
 && clevel=$(git l-debug-level) \
 && [ \"$level\" -le \"$clevel\" ] && exit 0 || exit 1 \
;}; f"

###################
# my worlflow
###################

# Сделать временный бекап текущей ветки в репу $dst (origin).
w-copy2tmp = "! git w-copy2tmp-default"
w-copy2tmp-default = "! f(){ \
 dst=${1:-origin} \
 && showlog=${2:-} \
 && user=$(git mynikname) \
 && cbr=$(git get-current-branch) \
 && rbranch=_${user}_${cbr}_tmp \
 && CURDATE=$(date +"%y%m%d_%H%M%S") \
 && MESS=$(echo \"Tmp commit of branch '${cbr}'. Date: ${CURDATE}.\") \
 && git l-echo-l0 \"w-copy2tmp $dst $showlog\" \
 && git l-echo-l1 \"w-copy2tmp 1-4:\";git l-echo \"git add --all\"                  && git add --all \
 && git l-echo-l1 \"w-copy2tmp 2-4:\";git l-echo \"git commit -am '$MESS'\"         && git commit -m \"${MESS}\" \
 && git l-echo-l1 \"w-copy2tmp 3-4:\";git l-echo \"git push -f $dst $cbr:$rbranch\" && git push -f $dst $cbr:$rbranch \
 && git l-echo-l1 \"w-copy2tmp 4-4:\";git l-echo \"git reset HEAD~1\"               && git reset HEAD~1 \
 && git l-checklast $showlog \
;}; f"

# Сделать копию $cfg в репу $dst (origin).
# Конечная ветка: не меняется.
w-backupcfg = "! git w-backupcfg-default"
w-backupcfg-default = "! f(){ \
 cfg=${1:-cfg} \
 && dst=${2:-origin} \
 && showlog=${3:-} \
 && user=$(git mynikname) \
 && rbranch=_${user}_${cfg}_backup \
 && git l-echo-l0 \"w-backupcfg $cfg $dst $showlog\" \
 && git l-echo-l1 \"w-backupcfg 1-1:\";git l-echo \"git push -f $dst $cfg:$rbranch\" && git push -f $dst $cfg:$rbranch \
 && git l-checklast $showlog \
;}; f"

# Создать первичные ветки для работы 3-х веточной схемы (MCF).
# Конечная ветка: $fix.
w-create-base = "! git w-create-base-default"
w-create-base-default = "! f(){ \
 fix=${1:-fix} \
 && cfg=${2:-cfg} \
 && master=${3:-master} \
 && showlog=${4:-show} \
 && git l-echo-l0 \"w-create-base $fix $cfg $master $showlog\" \
 && git l-echo-l1 \"w-create-base 1-3:\";git l-echo \"git checkout $master\" && git checkout $master  \
 && git l-echo-l1 \"w-create-base 2-3:\";git l-echo \"git checkout -b $cfg\" && git checkout -b $cfg \
 && git l-echo-l1 \"w-create-base 3-3:\";git l-echo \"git checkout -b $fix\" && git checkout -b $fix \
 && git l-checklast $showlog \
;}; f"

# Поменять базовый коммит для $cfg и $fix, т.е. подготовить ветки к 3-х веточной схемы работы.
# Конечная ветка: $fix.
w-rebuild-base = "! git w-rebuild-base-default"
w-rebuild-base-default = "! f(){ \
 fix=${1:-fix} \
 && cfg=${2:-cfg} \
 && master=${3:-master} \
 && showlog=${4:-show} \
 && git l-echo-l0 \"w-rebuild-base $fix $cfg $master $showlog\" \
 && git l-echo-l1 \"w-rebuild-base 1-2:\";git l-echo \"git rebase $master $cfg\" && git rebase $master $cfg \
 && git l-echo-l1 \"w-rebuild-base 1-2:\";git l-echo \"git rebase $cfg $fix\"    && git rebase $cfg $fix \
 && git l-checklast $showlog \
;}; f"

# Этот метод можно переопределить в локальном конфиге, чтобы при обновлении (пше w-update) выполнить дополнительную комманду.
# Например, чтобы выполнить дополнительную синхронизацию.
# Конечная ветка: не меняется.
w-update-extcmd = "! git w-update-extcmd-default"
w-update-extcmd-default = "! f(){ \
 fix=${1:-fix} \
 && cfg=${2:-cfg} \
 && master=${3:-master} \
 && src1=${4:-origin} \
 && src1_rbranch=${5:-$master} \
 && src2=${6:-$src1} \
 && src2_lbranch=${7:-$master} \
 && src2_rbranch=${8:-$src2_lbranch} \
 && showlog=${9:-show} \
 && git l-echo-l0 \"w-update-extcmd $fix $cfg $master $src1 $src1_rbranch $src2 $src2_lbranch $src2_rbranch $showlog\" \
 && git l-checklast $showlog \
;}; f"

# Залить новые изменения в ветку $brach (master) из ветки $src_branch ($master) репы $src (origin).
# Конечная ветка: $branch.
w-load-fix-from-repo = "! git w-load-fix-from-repo-default"
w-load-fix-from-repo-default = "! f(){ \
 branch=${1:-master} \
 && src=${2:-origin} \
 && src_lbranch=${3:-$master} \
 && src_rbranch=${4:-$src_lbranch} \
 && showlog=${5:-show} \
 && git l-echo-l0 \"w-load-fix-from-repo $branch $src $src_lbranch $src_rbranch $showlog\" \
 && if [ \"$branch\" = \"$src_lbranch\" ] \
; then \
    git l-echo-l1 \"w-load-fix-from-repo 1-2:\";git l-echo \"git checkout $branch\"                 && git checkout $branch \
 && git l-echo-l1 \"w-load-fix-from-repo 2-2:\";git l-echo \"git pull --rebase $src $src_rbranch \" && git pull --rebase $src $src_rbranch \
; else \
    git l-echo-l1 \"w-load-fix-from-repo 1-4:\";git l-echo \"git checkout $src_lbranch \"  && git checkout $src_lbranch \
 && git l-echo-l1 \"w-load-fix-from-repo 2-4:\";git l-echo \"git pull $src $src_rbranch \" && git pull $src $src_rbranch \
 && git l-echo-l1 \"w-load-fix-from-repo 3-4:\";git l-echo \"git checkout $branch \" && git checkout $branch \
 && git l-echo-l1 \"w-load-fix-from-repo 4-4:\";git l-echo \"git merge --no-edit $src_lbranch \" && git merge --no-edit -m \"Merged with $src/$src_rbranch\" $src_lbranch \
; fi \
 && git l-checklast $showlog \
;}; f"

# Обновить $master из 2х источников
# $src1 (origin) - основное хранилище, $src1_branch ($master) - источник правок в $src1
# имя удаленной ветки $src1_rbranch из источника $src1 для $master
# $src2 ($src1) - дополнительный источник,  $src2_lbranch ($src1_branch), $src2_rbranch ( $src2_lbranch ) - источник правок в $src2
# $src2_lbranch - локальное имя удаленной ветки $src2_rbranch из источника $src2
# 1) Сначала обновить $master из удаленной ветки $src1_branch репы $src1 методом pull --rebase.
# 2) Затем обновить $master из удаленной ветки $src2_branch репы $src2 методом merge,
#    только если второй источник отличается от первого
# Конечная ветка: $fix.
w-update = "! git w-update-default"
w-update-default = "! f(){ \
 fix=${1:-fix} \
 && cfg=${2:-cfg} \
 && master=${3:-master} \
 && src1=${4:-origin} \
 && src1_rbranch=${5:-$master} \
 && src2=${6:-$src1} \
 && src2_lbranch=${7:-$master} \
 && src2_rbranch=${8:-$src2_lbranch} \
 && showlog=${9:-show} \
 && git l-echo-l0 \"w-update $fix $cfg $master $src1 $src1_rbranch $src2 $src2_lbranch $src2_rbranch $showlog\" \
 && git l-echo-l1 \"w-update 1-5:\" && git w-load-fix-from-repo $master $src1 $master $src1_rbranch off \
 && if [ \"$src1\" = \"$src2\" -a \"$src1_rbranch\" = \"$src2_lbranch\" ] \
; then \
    git l-echo-l1 \"w-update 2-5: there is not need update\" \
; else \
    git l-echo-l1 \"w-update 2-5:\" && git w-load-fix-from-repo $master $src2 $src2_lbranch $src2_rbranch off \
; fi \
 && git l-echo-l1 \"w-update 3-5:\";git l-echo \"git push $src1 $master:$src1_rbranch\" && git push $src1 $master:$src1_rbranch \
 && git l-echo-l1 \"w-update 4-5:\" && git w-rebuild-base $fix $cfg $master off \
 && cbr=$(git get-current-branch) \
 && git l-echo-l1 \"w-update 5-5:\" && git w-update-extcmd $fix $cfg $master $src1 $src1_rbranch $src2 $src2_lbranch $src2_rbranch off \
 && git checkout -q $cbr \
 && git l-checklast $showlog \
;}; f"

# 1) Обновить $master из одной или двух веток (параметры см. w-update),
#    $src1 (origin) - основное хранилище, $src2 ($src1) - дополнительный источник
# 2) Залить изменения из $fix в $master. Отправить $master в ветку $src1_branch ($master) репы $src1 (origin).
#    Сделать бекап $cfg.
# Конечная ветка: $fix.
w-upload = "! git w-upload-default"
w-upload-default = "! f(){ \
 fix=${1:-fix} \
 && cfg=${2:-cfg} \
 && master=${3:-master} \
 && src1=${4:-origin} \
 && src1_rbranch=${5:-$master} \
 && src2=${6:-$src1} \
 && src2_lbranch=${7:-$master} \
 && src2_rbranch=${8:-$src2_lbranch} \
 && showlog=${9:-show} \
 && git l-echo-l0 \"w-upload $fix $cfg $master $src1 $src1_rbranch $src2 $src2_lbranch $src2_rbranch $showlog\" \
 && git l-echo-l1 \"w-upload 1-2:\" && git w-update $fix $cfg $master $src1 $src1_rbranch $src2 $src2_lbranch $src2_rbranch off \
 && git l-echo-l1 \"w-upload 2-2:\" && git w-send-fix $fix $cfg $master $src1 $src1_rbranch off \
 && git l-checklast $showlog \
;}; f"

# Аналогично w-upload, другой порядок парaметров.
# Сначала обязательно указываются параметры для второго источника, потом
# остальные параметры указываются или берутся по-умолчанию, как для w-update.
# Это удобно, когда нужно просто подлить в умолчательные ветки новое из второго источника,
# но остальные параметры взять по-умолчанию
# Конечная ветка: $fix.
w-upload2 = "! git w-upload2-default"
w-upload2-default = "! f(){ \
 if [ $# -lt 3 ]; then git l-echo \"Error: w-upload2 have to start with 3 or more parameters.\" 1 1 && exit 1 ; fi \
 && src2=${1:-$src1} \
 && src2_lbranch=${2:-$master} \
 && src2_rbranch=${3:-$src2_lbranch} \
 && fix=${4:-fix} \
 && cfg=${5:-cfg} \
 && master=${6:-master} \
 && src1=${7:-origin} \
 && src1_rbranch=${8:-$master} \
 && showlog=${9:-show} \
 && git l-echo-l0 \"w-upload2 $fix $cfg $master $src1 $src1_rbranch $src2 $src2_lbranch $src2_rbranch $showlog\" \
 && git l-echo-l1 \"w-upload2 1-1:\" && git w-upload $fix $cfg $master $src1 $src1_rbranch $src2 $src2_lbranch $src2_rbranch $showlog \
;}; f"

# Залить изменения из $fix в master.
# Отправить $master в ветку $dst_branch ($master) репы $dst ($origin).
# Сделать бекап $cfg.
# Конечная ветка: $fix.
w-send-fix = "! git w-send-fix-default"
w-send-fix-default = "! f(){ \
 fix=${1:-fix} \
 && cfg=${2:-cfg} \
 && master=${3:-master} \
 && dst=${4:-origin} \
 && dst_branch=${5:-$master} \
 && showlog=${6:-show} \
 && git l-echo-l0 \"w-send-fix $fix $cfg $master $dst $dst_branch $showlog\" \
 && git l-echo-l1 \"w-send-fix 1-3:\" && git w-apply-fix $fix $cfg $master off \
 && git l-echo-l1 \"w-send-fix 2-3:\";git l-echo \"git push $dst $master:$dst_branch\" && git push $dst $master:$dst_branch \
 && git l-echo-l1 \"w-send-fix 3-3:\" && git w-backupcfg $cfg $dst off \
 && git l-checklast $showlog \
;}; f"

# Загрузить свои изменения из ветки $fix в ветку $master, исключая коммиты ветки $cfg.
# Конечная ветка: $fix.
w-apply-fix = "! git w-apply-fix-default"
w-apply-fix-default = "! f(){ \
 fix=${1:-fix} \
 && cfg=${2:-cfg} \
 && master=${3:-master} \
 && showlog=${4:-show} \
 && git l-echo-l0 \"w-apply-fix $fix $cfg $master $showlog\" \
 && git l-echo-l1 \"w-apply-fix 1-4:\";git l-echo \"git checkout $fix\"                   && git checkout $fix \
 && git l-echo-l1 \"w-apply-fix 2-4:\";git l-echo \"git rebase --onto $master $cfg $fix\" && git rebase --onto $master $cfg $fix  \
 && git l-echo-l1 \"w-apply-fix 3-4:\";git l-echo \"git git rebase $fix $master\"         && git rebase $fix $master \
 && git l-echo-l1 \"w-apply-fix 4-4:\"                                                    && git w-rebuild-base $fix $cfg $master off \
 && git l-checklast $showlog \
;}; f"


#######################################
# git-svn useful (old workflow)
# TODO: Refacroting usiong new workflow
#######################################

pushall      = ! echo "=  pushall"         && git push --all origin
pushallforce = ! echo "=  pushallforce"    && git push --all --force origin

svnlog = !git svn log --oneline -20 | sort
svndcommit   = ! echo "=  git svn dcommit" && git svn dcommit

uploadsvn = "! f(){ \
 fix=${1:-fix} && cfg=${2:-cfg} && master=${3:-master} \
 && echo "=  uploadsvn $fix $cfg $master " \
 && git pushallforce \
 && git updatesvn $fix $cfg $master \
 && git loadsvn $fix $cfg $master \
 && git svndcommit \
 && git updatesvn $fix $cfg $master  \
 && git pushallforce \
 && echo "=====" && git last \
 && echo "=====" && git svnlog ;}; f"

updatesvn = "! f(){ \
 fix=${1:-fix} && cfg=${2:-cfg} && master=${3:-master} \
 && echo "=  updatesvn ${fix} ${cfg} ${master} " \
 && echo "== git checkout $master"    && git checkout $master  \
 && echo "== git svn rebase"          && git svn rebase \
 && echo "== git rebase $master $cfg" && git rebase $master $cfg \
 && echo "== git rebase $cfg $fix"    && git rebase $cfg $fix ;}; f"

loadsvn = "! f(){ \
 fix=${1:-fix} && cfg=${2:-cfg} && master=${3:-master} \
 && echo "=  loadsvn $fix $cfg $master " \
 && echo "== git checkout $fix"                   && git checkout $fix \
 && echo "== git rebase --onto $master $cfg $fix" && git rebase --onto $master $cfg $fix  \
 && echo "== git checkout $master"                && git checkout $master \
 && echo "== git rebase $fix $master"             && git rebase $fix $master ;}; f"

###################
### End ALIASES ###
###################

[commit]
#	template = /home/yournik/.gitmessage_template
[color]
	ui = true
	status = true
	diff = true
	branch = true
	interactive = true
	pager = true
	grep = true
[color "log"]
    current = green
    local = yellow
    remote = green reverse
[color "branch"]
    current = green bold
    local = yellow
    remote = cyan
[color "diff"]
    commit = yellow bold
    meta = normal bold
    frag = magenta bold
    old = red
    new = green
    whitespace = red reverse blink
    plain = normal
    func = normal
[color "status"]
    added = green dim
    changed = cyan
    untracked = yellow
[core]
    whitespace = fix,-indent-with-non-tab,trailing-space,cr-at-eol
    pager = less -FXRS
	editor = mcedit
#    FOR WIN
#	autocrlf = true
	autocrlf = false
	safecrlf = false
	eol = native
#    FOR WIN
#    pager = more
#    git config --global core.autocrlf true
#    git config --global core.safecrlf true
[blame]
	data = short
[gui]
	spellingdictionary = en_GB
[merge]
	tool = kdiff3
    guitool = kdiff3
[diff]
	tool = kdiff3
	guitool = kdiff3
[difftool]
	prompt = false
[mergetool]
	prompt = true
[help]
    autocorrect = 0
[http]
	sslverify = false
[push]
    default = upstream