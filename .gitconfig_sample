#customize your personal info
#   user.name
#   user.email
#   mcf.nickname
[user]
	name = your_name
	email = your@mail
[commit]
#    template = /home/yournick/.gitmessage_template
[color]
    ui = true
    status = true
    diff = true
    branch = true
    interactive = true
    pager = true
    grep = true
[color "log"]
    current = green
    local = yellow
    remote = green reverse
[color "branch"]
    current = green bold
    local = yellow
    remote = cyan
[color "diff"]
    commit = yellow bold
    meta = normal bold
    frag = magenta bold
    old = red
    new = green
    whitespace = red reverse blink
    plain = normal
    func = normal
[color "status"]
    added = green dim
    changed = cyan
    untracked = yellow
[core]
	commentchar = ";"
    pager = less -FXRS
    whitespace = fix,-indent-with-non-tab,trailing-space,cr-at-eol
#    edit = mcedit
# FOR LINUX
	autocrlf = input
    safecrlf = false
    eol = native
# FOR WIN
#    pager = more
#    core.autocrlf true
#    core.safecrlf true
[blame]
    data = short
[gui]
    spellingdictionary = en_GB
[merge]
    tool = kdiff3
    guitool = kdiff3
[diff]
    tool = kdiff3
    guitool = kdiff3
[difftool]
    prompt = false
[mergetool]
    prompt = false
[help]
    autocorrect = 0
[http]
    sslverify = false
[push]
    default = upstream

####################################################################################

#####################
### Start ALIASES ###
#####################
[alias]

###############
# Main commands
###############

br = branch
co = checkout
ci = commit
amend = commit --amend -C HEAD
st = status
rb = rebase
rbi = rebase -i
ch = cherry-pick
unstage = reset HEAD

# diff
df = diff
df0 = diff -U0
dfc = diff --cached
visual = !gitk --all &

# show history and log
sshow = "! f() { git --no-pager show --no-notes --stat --pretty=format:\"%C(yellow)%ad %C(green)%h%C(cyan)%d%Creset | %s %C(black bold)[%an]%Creset\"  --date=short --decorate $@ && echo  ; }; f"
hist  = "! f() { git --no-pager log                    --pretty=format:\"%C(yellow)%ad %C(green)%h%C(cyan)%d%Creset | %s %C(black bold)[%an]%Creset\"  --graph --date=short --decorate $@ && echo ; }; f"
hist2 = "! f() { git --no-pager log                    --pretty=format:\"%C(yellow)%ad %C(green)%h%Creset | %s %C(black bold)[%an]%Creset\"            --graph --date=short --decorate $@ && echo ; }; f"
hist3 = "! f() { git --no-pager log                    --pretty=format:\"%C(yellow)%ad %C(green)%h%Creset | %s %C(cyan)%d %C(black bold)[%an]%Creset\" --graph --date=short --decorate $@ && echo  ; }; f"
hist4 = "! f() { git --no-pager log                    --pretty=format:\"%C(yellow)%ad %C(green)%h%Creset | %s %Creset\" --graph --date=short --decorate $@ && echo  ; }; f"
last  = "! git hist  -20 $* "
last2 = "! git hist2 -20 $* "
last3 = "! git hist3 -20 $* "

###########
# User info
###########

myname     = "! git config user.name"
myemail    = "! git config user.email"
mynickname = "! git config mcf.l-nickname | sed 's/ /_/g'"

#Check labels in sources. Useful look for nickname, f.e. in comments
mycheck = "! f() { \
 allname=${1:-$(git mynickname)} \
 && git l-echo \"Find '$allname' in sources\" 6  \
 && git --no-pager grep -nEe \"${allname}\" \
;}; f "

#Show log for current user without sort
mylog = "! f() { \
 name=$(git myname) \
 && name=$(echo $name | sed 's/ /./g') \
 && echo \"Log for user (regex): '$name'\" \
 && git hist2 --author=\"$name\" $@ \
;}; f "

mylogshort = "! f() { \
 name=$(git myname) \
 && name=$(echo $name | sed 's/ /./g') \
 && echo \"Log for user (regex): '$name'\" \
 && git hist4 --author=\"$name\" $@ \
;}; f "

#Show log for current user sorted by date
mylogsort = "! f() { \
 git mylog $@ | sort -k 2,2 -r \
;}; f"

#Show log for current user without sort
myreport = "! f() { \
 name=$(git myname) \
 && name=$(echo $name | sed 's/ /./g') \
 && echo \"Log for user (regex): '$name'\" \
 && git hist4 --author-date-order --author=\"$name\" -20 $@ \
;}; f "


#################
# Useful commands
#################

# see gitignore rules
gi-list="! git gi list"
# get rules for gitignore: git gi netbeans
gi = "! gi() { curl -L -s https://www.gitignore.io/api/$@ ;}; gi"

current-branch-name = "! git cbr"
cbr = rev-parse --abbrev-ref HEAD

# ignored
# Show files ignored by git:
ign = "! git status --ignored --short | awk '/^!!/ { print $2 }'"
ign-cd = ls-files -o -i --exclude-standard


# temporarily ignoring file
ignore   = update-index --assume-unchanged
unignore = update-index --no-assume-unchanged
# to see the list of the ignored files.
ignored = "!git ls-files -v | grep ^[a-z]"

# check merged
merged   = branch --merged
unmerged = branch --no-merged

# different list and logs
ls = ls-files
lg    = "! f() { git --no-pager log -p $@ && echo ;}; f "
lol   = "! f() { git --no-pager log       --graph --decorate --pretty=oneline --abbrev-commit $@       && echo ;}; f "
lola  = "! f() { git --no-pager log --all --graph --decorate --pretty=oneline --abbrev-commit --all $@ && echo ;}; f "

type = cat-file -t
dump = cat-file -p

fsckclear = "! f(){ \
 git l-echo \"git fsck\"                                            && git fsck \
 && git l-echo \"git reflog expire --expire-unreachable=now --all\" && git reflog expire --expire-unreachable=now --all \
 && git l-echo \"git gc --prune prunefsck\"                         && git gc --prune=now \
 && git l-echo \"git fsck\"                                         && git fsck \
 && git l-echo \"git gc\"                                           && git gc \
;}; f"

###################
# my workflow
###################

################
# Local commands
################

# Показать сообщение нужным цветом и оттенком
# COLOR={0..7}
#  0-Black(Grey), 1-Red, 2-Green, 3-Brown/Orange(Yellow), 4-Blue,  5-Purple, 6-Cyan, 7-Light Gray(White)
# BRIGHT={0|1|2|4|7|9}
#  0(normal), 1(light), 2(dark), 4(underline), 7(invert) 9(cross)
l-echo = "! f() { \
 MESS=${1:-} \
 && COLOR=${2:-3} \
 && BRIGHT=${3:-1} \
 && COLOR=\"\\033[${BRIGHT};3${COLOR}m\" \
 && NOCOLOR=\"\\033[0m\" \
 && MESS=\"${COLOR}${MESS}${NOCOLOR}\" \
 && [ \"$(uname)\" = 'Linux' ] && echo \"$MESS\" || echo -e \"$MESS\" \
  ; exit 0 \
;}; f"

l-echo-l1 = "! f() { \
 MESS=${1:-} \
 && COLOR=${2:-2} \
 && BRIGHT=${3:-2} \
 && git l-debug-level-check 1 \
 && git l-echo \"= $MESS\" \"$COLOR\" \"$BRIGHT\" \
  ; exit 0 \
;}; f"

l-echo-l2 = "! f() { \
 MESS=${1:-} \
 && COLOR=${2:-6} \
 && BRIGHT=${3:-2} \
 && git l-debug-level-check 2 \
 && git l-echo \"== $MESS\" \"$COLOR\" \"$BRIGHT\" \
  ; exit 0 \
;}; f"

# Посмотреть последние коммиты текущей ветки, если $showlog=show|on|''
# Конечная ветка: не меняется.
l-showlog = "! f(){ \
 showlog=${1:-on} \
 && [ $(git l-check-is-on $showlog) = 'on' ] && (git l-echo '--- Please check ---' 5 && git last) || : \
;}; f"

l-debug-level-check = "! f() { \
 level=${1:-0} && [ \"$level\" -le \"$(git w-get-mcf-param l-debug-level)\" ] \
;}; f"

# Проверяет наличие локальной ветки 0-существует, 1-нет
l-check-exists-branch = "! f(){ \
 value=${1:-''} \
 status=1 \
 && if [ \"$1\" != '' ]; then \
       git branch | grep -w $1 >/dev/null; \
       status=$?; \
    fi; \
 echo $status; \
 return $status \
;}; f"

# Проверяет статус переменной: возвращает on или off
l-check-is-on = "! f(){ \
 value=${1:-''} \
 && empty_is_true=${2:-1} \
 && if [ \"$empty_is_true\" = '1' -a \"$value\" = '' ]; then status=on; \
    elif [ \"$value\" = 'on' -o \"$value\" = '1' ]; then status=on; else status=off; fi \
 && echo $status \
;}; f"

l-list-mcf-param = "! f() { \
 type=${1:-'--global'} && git config \"$type\" --get-regex mcf.l- | sed 's/^mcf.//' | awk '{printf \"%-20.80s = %s\\n\",$1,$2 }' \
;}; f"

l-fix-mcf-param = "! f() { \
  s=${1-''} \
  && s=$(echo \"$s\" | sed 's/ /_/g') \
  ; echo $s \
;}; f"

l-rev = "! f() { \
  git rev-list "$1" | head -n 1 \
;}; f"

#################
# Global commands
#################

#  Все команды имеют основную версию команды (mcf-*) и дополнительную с префиксом (w-*).
#  Эти команды равнозначны, пока они не переопределены в локальном конфиге. Если необходимо, то переопределять лучше команды w-*, т.к. именно эти команды вызываются в расширенных командах.
#  Команды mcf-* нужно использовать, как команды с поведением по-умолчанию.
#  Расширенные команды выполняют работы с git согласно 3-веточной схемы. Все команды можно переопределять в локальных конфигах, чтобы изменить стандатное поведение.
#    #Пример
#    #Отключить бекап локального конфига (ветка $cfg) на удаленный сервер для команд w-upload*.
#    > vim /dir/to/project/.git/config
#      …
#      [alias]
#        w-backup-cfg= "! : "
#  При описании команд ниже запись $param = value  обозначает, что $param c параметром по-умолчанию value.
#  Все команды используют параметры по-умолчанию:
#    $fix = l-fix - имя ветки правок fix в схеме MCF
#    $cfg = l-cfg - имя ветки конфигурации cfg в схеме MCF
#    $master = l-master - имя основной ветки master в схеме MCF
#    $src1 = l-src1 -  имя основного источника
#    $src1_rbranch = l-src1-rbranch - имя удаленной (remote) ветки в основном источнике
#    $src2 = l-src2 - имя вспомогательного источника
#    $src2_rbranch = l-src2-rbranch - имя удаленной (remote) ветки вспомогательного источника
#    $showlog = show - показывать или не показывать (hide|off) log после выполнения команды
#    $rebuild_base = on - делать(on) или не ltkfnm(off) после выполнения команды переустановку базовых веток
#    $method = rebase - метод (rebase|merge), который использовать при получении новых изменений с удаленных (remote) источников

# Локальные константы l-*?, которые находятся в секции [mcf], предназначены, для инициализации параметров команд по-умолчанию, а также для переопределения значений параметров в локальных конфигах.
#   #Пример
#   #Изменить умолчательные имя локальных веток $master -> work и $fix -> dev для текущего проекта.
#   > vim /dir/to/project/.git/config.
#     …
#     [mcf]
#        l-master = work
#        l-fix    = dev
# Также все mcf,w-* команды можно адаптировать для работы с git-svn.
# Далее в примерах мы используем команды с индексом w-*, и они могут быть переопределены в локальных конфигах, так же удобнее и быстрее набирать на клавиатуре.

# w-create-base [ $fix $cfg $master $showlog ]
#  Создать ветки $cfg с базой от $master и $fix с базой от $cfg для работы cо схемой MCF. Если ветки уже были созданы ранее, то будет просто переход на них без изменения базовых коммитов.
#  Конечная ветка: $fix.
  w-create-base = "! git mcf-create-base"
mcf-create-base = "! f(){ \
 CMD='w-create-base' \
 &&     fix=${1:-$(git w-get-mcf-param l-fix)} \
 &&     cfg=${2:-$(git w-get-mcf-param l-cfg)} \
 &&  master=${3:-$(git w-get-mcf-param l-master)} \
 && showlog=${4:-on} \
 && git l-echo-l1 \"$CMD $fix $cfg $master $showlog\" \
 && git l-echo-l2 \"$CMD 1-3:\";git l-echo \"git checkout $master\" && git checkout -q $master  \
 && git l-echo-l2 \"$CMD 2-3:\"; \
    if [ \"$(git l-check-exists-branch $cfg)\" = '0' ]; then \
      git l-echo \"git checkout $cfg\" && git checkout -q $cfg ; \
    else \
      git l-echo \"git checkout -b $cfg $master\" && git checkout -b $cfg $master ; \
    fi ; \
    if [ \"$(git l-check-exists-branch $fix)\" = '0' ]; then \
      git l-echo \"git checkout $fix\" && git checkout -q $fix ; \
    else \
      git l-echo \"git checkout -b $fix $cfg\" && git checkout -b $fix $cfg ; \
    fi \
 && git l-showlog $showlog \
;}; f"

# w-rebuild-base [ $fix $cfg $master $showlog ]
#  Переустановить базовые коммиты для $cfg и $fix, т.е. подготовить ветки для работы по схеме MCF.
#  Обычно делается всегда после правки конфигурации, или после обновления $master, чтобы внести изменения в базовые ветки.
#  Конечная ветка: $fix.
  w-rebuild-base = "! git mcf-rebuild-base"
mcf-rebuild-base = "! f(){ \
 CMD='w-rebuild-base' \
 &&     fix=${1:-$(git w-get-mcf-param l-fix)} \
 &&     cfg=${2:-$(git w-get-mcf-param l-cfg)} \
 &&  master=${3:-$(git w-get-mcf-param l-master)} \
 && showlog=${4:-on} \
 && git l-echo-l1 \"$CMD $fix $cfg $master $showlog\" \
 && if [ \"$(git l-check-exists-branch $cfg)\" != '0' -o \"$(git l-check-exists-branch $fix)\" != '0' ]; then git w-create-base $fix $cfg $master off; fi \
 && git l-echo-l2 \"$CMD 1-2:\";git l-echo \"git rebase $master $cfg\" && git rebase $master $cfg \
 && git l-echo-l2 \"$CMD 2-2:\";git l-echo \"git rebase $cfg $fix\"    && git rebase $cfg $fix \
 && git l-showlog $showlog \
;}; f"

# w-load-fix-from-repo [ $master $src1 $src1_rbranch $method $showlog ]
#  Залить новые изменения в ветку $master из источника $src1 $src1_rbranch используя $method=rebase|merge.
#  Если $method=rebase, то используется git pull --rebase, а иначе git merge.
#  Конечная ветка: $master.
  w-load-fix-from-repo = "! git mcf-load-fix-from-repo"
mcf-load-fix-from-repo = "! f(){ \
 CMD='w-load-fix-from-repo' \
 &&       master=${1:-$(git w-get-mcf-param l-master)} \
 &&         src1=${2:-$(git w-get-mcf-param l-src1)} \
 && src1_rbranch=${3:-$(git w-get-mcf-param l-src1-rbranch)} \
 &&       method=${4:-rebase} \
 &&      showlog=${5:-on} \
 && git l-echo-l1 \"$CMD $master $src1 $src1_rbranch $method $showlog\" \
 && if [ \"$method\" = \"rebase\" ] \
; then \
    git l-echo-l2 \"$CMD 1-2:\";git l-echo \"git checkout $master\"                   && git checkout -q $master \
 && git l-echo-l2 \"$CMD 2-2:\";git l-echo \"git pull --rebase $src1 $src1_rbranch \" && git pull --no-edit --rebase $src1 $src1_rbranch \
; else \
    git l-echo-l2 \"$CMD 1-3:\";git l-echo \"git fetch $src1 $src1_rbranch \" && git fetch $src1 $src1_rbranch \
 && git l-echo-l2 \"$CMD 2-3:\";git l-echo \"git checkout $master\"           && git checkout -q $master \
 && git l-echo-l2 \"$CMD 3-3:\";git l-echo \"git merge $src1/$src1_rbranch \" && git merge --no-edit $src1/$src1_rbranch \
; fi \
 && git l-showlog $showlog \
;}; f"

# w-update-common [ $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $rebuild_base $showlog ]
#  Залить обновление в $master из 2-х источников.
#  Обновить $master из основного источника $src1/$src1_rbranch методом git pull --rebase.
#  Если первый и второй источник одинаковые ($src1 = $src2 && $src1_rbranch = $src2_rbranch), то обновление из второго источника пропускается.
#  Если первый и второй источник разные, то обновить $master из дополнительного источника $src2/$src2_rbranch методом git merge.
#  Параметр $rebuild_base=on|off указывает, нужно ли после обновления делать переустановку базовых веток.
#  Конечная ветка: $fix.
  w-update-common = "! git mcf-update-common"
mcf-update-common = "! f(){ \
 CMD='w-update-common' \
 &&          fix=${1:-$(git w-get-mcf-param l-fix)} \
 &&          cfg=${2:-$(git w-get-mcf-param l-cfg)} \
 &&       master=${3:-$(git w-get-mcf-param l-master)} \
 &&         src1=${4:-$(git w-get-mcf-param l-src1)} \
 && src1_rbranch=${5:-$(git w-get-mcf-param l-src1-rbranch)} \
 &&         src2=${6:-$(git w-get-mcf-param l-src2)} \
 && src2_rbranch=${7:-$(git w-get-mcf-param l-src2-rbranch)} \
 && rebuild_base=${8:-on} \
 &&      showlog=${9:-on} \
 && git l-echo-l1 \"$CMD $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $rebuild_base $showlog\" \
 && git l-echo-l2 \"$CMD 1-4:\" && git w-load-fix-from-repo $master $src1 $src1_rbranch rebase off \
 && if [ \"$src1\" = \"$src2\" -a \"$src1_rbranch\" = \"$src2_rbranch\" ] \
; then git l-echo-l2 \"$CMD 2-4: do not need to update from src2\" \
; else git l-echo-l2 \"$CMD 2-4:\" && git w-load-fix-from-repo $master $src2 $src2_rbranch merge off \
; fi \
 && if [ \"$(git l-rev $master)\" != \"$(git l-rev $src1/$src1_rbranch)\"  ]; then git l-echo-l2 \"$CMD 2.2-4:\" && git l-echo \"git push $src1 $master:$src1_rbranch\" && git push $src1 $master:$src1_rbranch ; fi \
 && if [ \"$rebuild_base\" = 'on' ] \
; then git l-echo-l2 \"$CMD 3-4:\" && git w-rebuild-base $fix $cfg $master off \
; else git l-echo-l2 \"$CMD 3-4: do not need to do rebuild base\"\
; fi \
 && cbr=$(git current-branch-name) \
 && git l-echo-l2 \"$CMD 4-4:\" \
 && git l-echo-l1 \"w-update-extcmd $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch off\" \
 && git w-update-extcmd $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch off \
 && git checkout -q $cbr \
 && git l-showlog $showlog \
;}; f"

# w-update2 [ $src2 $src2_rbranch $fix $cfg $master $src1 $src1_rbranch $rebuild_base $showlog ]
#  Команда аналогична w-update-common, но другой порядок парaметров.
#  Первые два параметра определяют второй источник, потом указываются остальные параметры или берутся по-умолчанию, как для w-update-common.
#  Более удобна при работе с 2-мя источниками, чем w-update-common, когда используются параметры по-умолчанию, а нужно указать только параметры второго источника.
#  Конечная ветка: $fix.
  w-update2 = "! git mcf-update2"
mcf-update2 = "! f(){ \
 CMD='w-update2' \
 &&         src2=${1:-$(git w-get-mcf-param l-src2)} \
 && src2_rbranch=${2:-$(git w-get-mcf-param l-src2-rbranch)} \
 &&          fix=${3:-$(git w-get-mcf-param l-fix)} \
 &&          cfg=${4:-$(git w-get-mcf-param l-cfg)} \
 &&       master=${5:-$(git w-get-mcf-param l-master)} \
 &&         src1=${6:-$(git w-get-mcf-param l-src1)} \
 && src1_rbranch=${7:-$(git w-get-mcf-param l-src1-rbranch)} \
 && rebuild_base=${8:-on} \
 &&      showlog=${9:-on} \
 && git l-echo-l1 \"$CMD $src2 $src2_rbranch $fix $cfg $master $src1 $src1_rbranch $rebuild_base $showlog\" \
 && git l-echo-l2 \"$CMD 1-1:\" && git w-update-common $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $rebuild_base $showlog \
;}; f"

# w-update [ $fix $cfg $master $src1 $src1_rbranch $rebuild_base $showlog ]
#  Залить обновление в $master из 1-го источника.
#  Обновить $master из основного источника $src1/$src1_rbranch методом git pull --rebase.
#  Используется w-update-common, но $src1 = $src2 && $src1_rbranch = $src2_rbranch, поэтому обновление из второго источника пропускается.
#  Параметр $rebuild_base=on|off указывает, нужно ли после обновления делать переустановку базовых веток.
#  Конечная ветка: $fix.
  w-update = "! git mcf-update"
mcf-update = "! f(){ \
 CMD='w-update' \
 &&          fix=${1:-$(git w-get-mcf-param l-fix)} \
 &&          cfg=${2:-$(git w-get-mcf-param l-cfg)} \
 &&       master=${3:-$(git w-get-mcf-param l-master)} \
 &&         src1=${4:-$(git w-get-mcf-param l-src1)} \
 && src1_rbranch=${5:-$(git w-get-mcf-param l-src1-rbranch)} \
 && rebuild_base=${6:-on} \
 &&      showlog=${7:-on} \
 && src2=$src1 \
 && src2_rbranch=$src1_rbranch \
 && git l-echo-l1 \"$CMD $fix $cfg $master $src1 $src1_rbranch $rebuild_base $showlog\" \
 && git l-echo-l2 \"$CMD 1-1:\" && git w-update-common $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $rebuild_base $showlog \
;}; f"

# w-upload-common [ $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $showlog ]
#  Выгружает сделанные изменения из ветки $fix в ветку $master и на сервер $src1.
#  Сначала происходит обновление $master из источников $src1 и $src2 (см. w-update-common).
#  Затем изменения из $fix заливаются в $master и отправляются в $src1/$src1_rbranch.
#  Конечная ветка: $fix.
  w-upload-common = "! git mcf-upload-common"
mcf-upload-common = "! f(){ \
 CMD='w-upload-common' \
 &&          fix=${1:-$(git w-get-mcf-param l-fix)} \
 &&          cfg=${2:-$(git w-get-mcf-param l-cfg)} \
 &&       master=${3:-$(git w-get-mcf-param l-master)} \
 &&         src1=${4:-$(git w-get-mcf-param l-src1)} \
 && src1_rbranch=${5:-$(git w-get-mcf-param l-src1-rbranch)} \
 &&         src2=${6:-$(git w-get-mcf-param l-src2)} \
 && src2_rbranch=${7:-$(git w-get-mcf-param l-src2-rbranch)} \
 &&      showlog=${8:-on} \
 &&    do_backup=$(git w-get-mcf-param l-backup-cfg) \
 && git l-echo-l1 \"$CMD $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $showlog\" \
 && git l-echo-l2 \"$CMD 1-5:\" && git w-update-common $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch off off \
 && git l-echo-l2 \"$CMD 2-5:\" && git w-rebuild-base $fix $cfg $master off \
 && git l-echo-l2 \"$CMD 3-5:\" && git w-send-fix $fix $cfg $master $src1 $src1_rbranch off \
 && if [ $(git l-check-is-on $do_backup) = 'on' ] \
; then git l-echo-l2 \"$CMD 4-5:\"; git w-backup-cfg $cfg $src1 off \
; else git l-echo-l2 \"$CMD 4-5: skip backup $cfg\" ; fi \
 && cbr=$(git current-branch-name) \
 && git l-echo-l2 \"$CMD 5-5:\" \
 && git l-echo-l1 \"w-upload-extcmd $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch off\" \
 && git w-upload-extcmd $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch off \
 && git checkout -q $cbr \
 && git l-showlog $showlog \
;}; f"

# w-upload2 [ $src2 $src2_rbranch $fix $cfg $master $src1 $src1_rbranch $showlog ]
#  Команда аналогична w-upload-common, но другой порядок парaметров.
#  Первые два параметра определяют второй источник, потом указываются остальные параметры или берутся по-умолчанию, как для w-upload-common.
#  Более удобна при работе с 2-мя источниками, чем w-upload-common, если используюся параметры по-умолчанию, а нужно указать только параметры второго источника.
#  Конечная ветка: $fix.
  w-upload2 = "! git mcf-upload2"
mcf-upload2 = "! f(){ \
 CMD='w-upload2' \
 &&         src2=${1:-$(git w-get-mcf-param l-src2)} \
 && src2_rbranch=${2:-$(git w-get-mcf-param l-src2-rbranch)} \
 &&          fix=${3:-$(git w-get-mcf-param l-fix)} \
 &&          cfg=${4:-$(git w-get-mcf-param l-cfg)} \
 &&       master=${5:-$(git w-get-mcf-param l-master)} \
 &&         src1=${6:-$(git w-get-mcf-param l-src1)} \
 && src1_rbranch=${7:-$(git w-get-mcf-param l-src1-rbranch)} \
 &&      showlog=${8:-on} \
 && git l-echo-l1 \"$CMD $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $showlog\" \
 && git l-echo-l2 \"$CMD 1-1:\" && git w-upload-common $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $showlog \
;}; f"

# w-upload [ $fix $cfg $master $src1 $src1_rbranch $showlog ]
#  Выгружает сделанные изменения из ветки $fix в ветку $master и на сервер $src1.
#  Сначала происходит обновление $master из источника $src1 (см. w-update).
#  Затем изменения из $fix заливаются в $master и отправляются в $src1/$src1_rbranch.
#  Конечная ветка: $fix.
  w-upload = "! git mcf-upload"
mcf-upload = "! f(){ \
 CMD='w-upload' \
 &&          fix=${1:-$(git w-get-mcf-param l-fix)} \
 &&          cfg=${2:-$(git w-get-mcf-param l-cfg)} \
 &&       master=${3:-$(git w-get-mcf-param l-master)} \
 &&         src1=${4:-$(git w-get-mcf-param l-src1)} \
 && src1_rbranch=${5:-$(git w-get-mcf-param l-src1-rbranch)} \
 &&      showlog=${6:-on} \
 &&         src2=$src1 \
 && src2_rbranch=$src1_rbranch \
 && git l-echo-l1 \"$CMD $fix $cfg $master $src1 $src1_rbranch $showlog\" \
 && git l-echo-l2 \"$CMD 1-1:\" && git w-upload-common $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $showlog \
;}; f"

# w-update-extcmd [ $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $showlog ]
#  Эта команда выполняется после успешного выполнения обновления w-update-common.
#  Эту команду нужно переопределить в локальном конфиге, чтобы при обновлении можно было выполнить дополнительные действия.
#  Например, выполнить тесты, дополнительную синхронизацию, дополнительные системные программы и т.п.
#  Конечная ветка: зависит от переопределенной комманды.
#  # Пример: дополнительная синхронизация с 3-м сервером server3
#  > vim /dir/to/project/.git/config
#    …
#    [alias]
#      w-update-extcmd-default = "! f(){ \
#        master=$3\
#        && l-echo \"git push server3 $master:custom_branch\" \
#        &&          git push server3 $master:custom_branch   \
#      ;}; f"#    #Пример: дополнительная синхронизация с 3-м сервером server3
  w-update-extcmd = "! git mcf-update-extcmd"
mcf-update-extcmd = "! f(){ \
 CMD='w-update-extcmd' \
 &&          fix=${1:-$(git w-get-mcf-param l-fix)} \
 &&          cfg=${2:-$(git w-get-mcf-param l-cfg)} \
 &&       master=${3:-$(git w-get-mcf-param l-master)} \
 &&         src1=${4:-$(git w-get-mcf-param l-src1)} \
 && src1_rbranch=${5:-$(git w-get-mcf-param l-src1-rbranch)} \
 &&         src2=${6:-$(git w-get-mcf-param l-src2)} \
 && src2_rbranch=${7:-$(git w-get-mcf-param l-src2-rbranch)} \
 &&      showlog=${8:-on} \
;}; f"

# w-upload-extcmd [ $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $showlog ]
#  Эта команда выполняется после успешного выполнения w-upload.
#  Эту команду нужно переопределить в локальном конфиге, чтобы можно было выполнить дополнительные действия.
#  Например, выполнить тесты, дополнительную синхронизацию, дополнительные системные программы и т.п.
#  Конечная ветка: зависит от переопределенной комманды.
#  # Пример: отправка $master после w-upload-common на дополнительный сервер server2 в ветку remote_branch
#  > vim /dir/to/project/.git/config
#    …
#    [remote "server2"]
#       …
#    [alias]
#       w-upload-extcmd = "! f(){ \
#          master=$3 \
#          && git l-echo \"git push server2 $master:remote_branch\" \
#          &&              git push server2 $master:remote_branch   \
#       ;}; f"
  w-upload-extcmd = "! git mcf-upload-extcmd"
mcf-upload-extcmd = "! f(){ \
 CMD='w-upload-extcmd' \
 &&          fix=${1:-$(git w-get-mcf-param l-fix)} \
 &&          cfg=${2:-$(git w-get-mcf-param l-cfg)} \
 &&       master=${3:-$(git w-get-mcf-param l-master)} \
 &&         src1=${4:-$(git w-get-mcf-param l-src1)} \
 && src1_rbranch=${5:-$(git w-get-mcf-param l-src1-rbranch)} \
 &&         src2=${6:-$(git w-get-mcf-param l-src2)} \
 && src2_rbranch=${7:-$(git w-get-mcf-param l-src2-rbranch)} \
 &&      showlog=${8:-on} \
;}; f"

# w-apply-fix [ $fix $cfg $master $showlog ]
#  Загрузить свои изменения из ветки $fix в ветку $master, исключая коммиты ветки $cfg.
#  Конечная ветка: $fix.
  w-apply-fix = "! git mcf-apply-fix"
mcf-apply-fix = "! f(){ \
 CMD='w-apply-fix' \
 &&     fix=${1:-$(git w-get-mcf-param l-fix)} \
 &&     cfg=${2:-$(git w-get-mcf-param l-cfg)} \
 &&  master=${3:-$(git w-get-mcf-param l-master)} \
 && showlog=${4:-on} \
 && git l-echo-l1 \"$CMD $fix $cfg $master $showlog\" \
 && git l-echo-l2 \"$CMD 1-4:\";git l-echo \"git checkout $fix\"                   && git checkout -q $fix \
 && git l-echo-l2 \"$CMD 2-4:\";git l-echo \"git rebase --onto $master $cfg $fix\" && git rebase --onto $master $cfg $fix  \
 && git l-echo-l2 \"$CMD 3-4:\";git l-echo \"git rebase $fix $master\"             && git rebase $fix $master \
 && git l-echo-l2 \"$CMD 4-4:\"                                                    && git w-rebuild-base $fix $cfg $master off \
 && git l-showlog $showlog \
;}; f"

# w-send-fix [ $fix $cfg $master $src1 $src1_rbranch $showlog ]
#  Применить изменения (mcf-apply-fix) $fix к $master, и отправить их в $src1/$src1_rbranch.
#  Конечная ветка: $fix.
  w-send-fix = "! git mcf-send-fix"
mcf-send-fix = "! f(){ \
 CMD='w-send-fix' \
 &&          fix=${1:-$(git w-get-mcf-param l-fix)} \
 &&          cfg=${2:-$(git w-get-mcf-param l-cfg)} \
 &&       master=${3:-$(git w-get-mcf-param l-master)} \
 &&         src1=${4:-$(git w-get-mcf-param l-src1)} \
 && src1_rbranch=${5:-$(git w-get-mcf-param l-src1-rbranch)} \
 &&      showlog=${6:-on} \
 && git l-echo-l1 \"$CMD $fix $cfg $master $src1 $src1_rbranch $showlog\" \
 && git l-echo-l2 \"$CMD 1-2:\" && git w-apply-fix $fix $cfg $master off \
 && git l-echo-l2 \"$CMD 2-2:\";git l-echo \"git push $src1 $master:$src1_rbranch\" && git push $src1 $master:$src1_rbranch \
 && git l-showlog $showlog \
;}; f"

# w-repair-conflict-master [ $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $showlog ]
#  Устранить возможные проблемы после устранения конфликта в $master.
#  Отправить устраненные конфликты в $src1/$src1_rbranch
#  Все параметры как для w-upload-common.
#  Конечная ветка: $fix.
  w-repair-conflict-master = "! git mcf-repair-conflict-master"
mcf-repair-conflict-master = "! f(){ \
 CMD='w-repair-conflict-master' \
 &&          fix=${1:-$(git w-get-mcf-param l-fix)} \
 &&          cfg=${2:-$(git w-get-mcf-param l-cfg)} \
 &&       master=${3:-$(git w-get-mcf-param l-master)} \
 &&         src1=${4:-$(git w-get-mcf-param l-src1)} \
 && src1_rbranch=${5:-$(git w-get-mcf-param l-src1-rbranch)} \
 &&         src2=${6:-$(git w-get-mcf-param l-src2)} \
 && src2_rbranch=${7:-$(git w-get-mcf-param l-src2-rbranch)} \
 && rebuild_base=${8:-on} \
 &&      showlog=${9:-on} \
 && git l-echo-l1 \"$CMD $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $showlog\" \
 && git l-echo-l2 \"$CMD 1-2:\" && git w-rebuild-base $fix $cfg $master off \
 && git l-echo-l2 \"$CMD 2-2:\";git l-echo \"git push $src1 $master:$src1_rbranch\" && git push $src1 $master:$src1_rbranch \
 && git l-echo \"$CMD: All fixed. Please start conflicted command again.\"\
;}; f"

# w-repair-conflict-cfg [ $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $showlog ]
#  Устранить возмжные проблемы после устранения конфликта в $cfg
#  Все параметры как для w-upload-common.
#  Конечная ветка: $fix.
  w-repair-conflict-cfg = "! git mcf-repair-conflict-cfg"
mcf-repair-conflict-cfg = "! f(){ \
 CMD='w-repair-conflict-cfg' \
 &&          fix=${1:-$(git w-get-mcf-param l-fix)} \
 &&          cfg=${2:-$(git w-get-mcf-param l-cfg)} \
 &&       master=${3:-$(git w-get-mcf-param l-master)} \
 &&         src1=${4:-$(git w-get-mcf-param l-src1)} \
 && src1_rbranch=${5:-$(git w-get-mcf-param l-src1-rbranch)} \
 &&         src2=${6:-$(git w-get-mcf-param l-src2)} \
 && src2_rbranch=${7:-$(git w-get-mcf-param l-src2-rbranch)} \
 && rebuild_base=${8:-on} \
 &&      showlog=${9:-on} \
 && git l-echo-l1 \"$CMD $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $showlog\" \
 && git l-echo-l2 \"$CMD 1-1:\" && git w-rebuild-base $fix $cfg $master off \
 && git l-echo \"$CMD: All fixed. Please start conflicted command again.\"\
;}; f"

# w-repair-conflict-fix [ $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $showlog ]
#  Устранить возмжные проблемы после устранения конфликта в $fix
#  Все параметры как для w-upload-common.
#  Конечная ветка: $fix.
  w-repair-conflict-fix = "! git mcf-repair-conflict-fix"
mcf-repair-conflict-fix = "! f(){ \
 CMD='w-repair-conflict-fix' \
 &&          fix=${1:-$(git w-get-mcf-param l-fix)} \
 &&          cfg=${2:-$(git w-get-mcf-param l-cfg)} \
 &&       master=${3:-$(git w-get-mcf-param l-master)} \
 &&         src1=${4:-$(git w-get-mcf-param l-src1)} \
 && src1_rbranch=${5:-$(git w-get-mcf-param l-src1-rbranch)} \
 &&         src2=${6:-$(git w-get-mcf-param l-src2)} \
 && src2_rbranch=${7:-$(git w-get-mcf-param l-src2-rbranch)} \
 && rebuild_base=${8:-on} \
 &&      showlog=${9:-on} \
 && git l-echo-l1 \"$CMD $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $showlog\" \
 && git l-echo-l2 \"$CMD 1-1:\" && git w-rebuild-base $fix $cfg $master off \
 && git l-echo    \"$CMD: All fixed. Please start conflicted command again.\"\
;}; f"

# w-backup-cfg [ $cfg $src1 $showlog ]
#  Сделать бекап ветки конфигурации
#  Отправить копию ветки $cfg в репу $src1 c именем ветки '_{nickname}_{$cfg}_backup'.
#  Конечная ветка: не меняется.
  w-backup-cfg = "! git mcf-backup-cfg"
mcf-backup-cfg = "! f(){ \
 CMD='w-backup-cfg' \
 &&     cfg=${1:-$(git w-get-mcf-param l-cfg)} \
 &&    src1=${2:-$(git w-get-mcf-param l-src1)} \
 && showlog=${3:-on} \
 &&    nick=$(git mynickname) \
 && src1_rbranch=_${nick}_${cfg}_backup \
 && git l-echo-l1 \"$CMD $cfg $src1 $showlog\" \
 && git l-echo-l2 \"$CMD 1-1:\";git l-echo \"git push -f $src1 $cfg:$src1_rbranch\" && git push -f $src1 $cfg:$src1_rbranch \
 && git l-showlog $showlog \
;}; f"

# w-copy2tmp [ $src1 $showlog ]
#  Сделать временный бекап состояния текущей ветки.
#  Создается текущее состояние рабочего каталога в репу $src1 с именем ветки '_{nickname}_{name_of_current_branch}_tmp'. При бекапе все несохраненные изменения также отправятся в репу.
#  После завершения бекапа в рабочем катологе состояние файлов будет восстановлено, как до выполнения команды.
#  Эта операция полезна, если вы не готовы коммитить изменения, но нужно сделать копию текущего состояния.
#  Конечная ветка: не меняется.
  w-copy2tmp = "! git mcf-copy2tmp"
mcf-copy2tmp = "! f(){ \
 CMD='w-copy2tmp' \
 &&     src1=${1:-$(git w-get-mcf-param l-src1)} \
 && showlog=${2:-on} \
 &&    nick=$(git mynickname) \
 &&     cbr=$(git current-branch-name) \
 && src1_rbranch=_${nick}_${cbr}_tmp \
 && CURDATE=$(date +%y%m%d_%H%M%S) \
 && MESS=$(echo \"Tmp commit of branch '${cbr}'. Date: ${CURDATE}.\") \
 && TMPFILE='~__REMOVE_THIS_TMP_FILE__' \
 && touch \"$TMPFILE\" \
 && git l-echo-l1 \"$CMD $src1 $showlog\" \
 && git l-echo-l2 \"$CMD 1-4:\";git l-echo \"git add --all\"                   && git add --all \
 && git l-echo-l2 \"$CMD 2-4:\";git l-echo \"git commit -am '$MESS'\"          && git commit -m \"${MESS}\" \
 && git l-echo-l2 \"$CMD 3-4:\";git l-echo \"git push -f $src1 $cbr:$src1_rbranch\" && git push -f $src1 $cbr:$src1_rbranch \
 && git l-echo-l2 \"$CMD 4-4:\";git l-echo \"git reset HEAD~1\"                && git reset HEAD~1 \
 && rm -f \"$TMPFILE\" \
 && git l-showlog $showlog \
;}; f"

# w-fakecommit [ $mess $showlog ]
#  Создает фейковый коммит.
#  Создается коммит c пустым файлом и коментарием 'Fake: $mess'. По-умолчанию, комментарий - 'Fake: Added _fakefile_...'.
#  Команда используется для тестов и при исследовании git команд.
#  Конечная ветка: не меняется.
  w-fakecommit = "! git mcf-fakecommit "
mcf-fakecommit = "! f(){ \
 CMD='w-fakecommit' \
 &&    mess=${1:-} \
 && showlog=${2:-on} \
 && a=_fakefile_.$(basename $PWD).$(date +%Y%m%d_%H%M%S) \
 && if [ -z \"$mess\" ]; then mess=\"Added $a\"; fi \
 && sleep 1 && touch \"$a\" && git add \"$a\" -- && git commit -m \"Fake: $mess\" \
 && git l-showlog $showlog \
;}; f"

# w-get-mcf-param $name [,$typevar] [,$emptyok]
#  Показывает текущее значение параметра $name
#  Если параметр не найден, то будет выведено сообщение об ошибке и список текущих параметров
  w-get-mcf-param = "! git mcf-get-mcf-param "
mcf-get-mcf-param = "! f(){ \
 CMD='w-get-mcf-param' \
 && if [ $# -lt 1 ]; then git l-echo \"$CMD Error: parameter name is absent.\" 1; git w-list-mcf-param; exit 1;fi \
 && param=${1:-} \
 && typevar=${2:-} \
 && emptyok=${3:-'0'} \
 && value=$(git config ${typevar} \"mcf.${param}\" ) \
 ;  if [ \"$?\" != '0'   -a  \"$emptyok\" = '0' ]; then git l-echo \"$CMD Error: incorrect parameter name '$param'.\" 1; exit 1; fi\
 ;  if [ \"$value\" = '' -a  \"$emptyok\" = '0' ]; then git l-echo \"$CMD Error: parameter '$param' is empty'.\" 1; exit 1; fi \
 ;  echo \"$value\" \
;}; f"


# w-set-mcf-param $name $value [ $showlog ]
#  Устанавливает новое значение $value для параметра $name.
#  Установка происходит в локальном конфиге.
  w-set-mcf-param = "! git mcf-set-mcf-param "
mcf-set-mcf-param = "! f(){ \
 CMD='w-set-mcf-param' \
 && if [ $# -lt 2 ]; then git l-echo \"$CMD Error: must be minimum 2 parameters name and value.\" 1; git w-list-mcf-param; exit 1;fi \
 && param=${1:-} \
 && value=${2:-} \
 && showlog=${3:-on} \
 && if [ \"$value\" = '' ]; then git l-echo \"$CMD Error: value is empty.\" 1; exit 1; fi \
 && oldvalue=$(git w-get-mcf-param \"$param\") \
 && value=$(git l-fix-mcf-param \"$value\") \
 && if [ $(git config \"mcf.${param}\" \"$value\") ]; then git l-echo \"$CMD Error when set new value '$value' of param $param'.\" 1; exit 1; fi \
 && if [ $(git l-check-is-on $showlog) != 'on' ]; then return 0; fi \
 && newvalue=$(git w-get-mcf-param \"$param\") \
 && git l-echo \"Old: $param = $oldvalue\" 4 1\
 && git l-echo \"New: $param = $newvalue\" 2 0\
 && git w-list-mcf-param \
;}; f"

# w-del-mcf-param $name [ $showlog ]
#  Удаляет локальное значение параметра c именем $name, если параметр существует в локальном конфиг файле git.
  w-del-mcf-param = "! git mcf-del-mcf-param "
mcf-del-mcf-param = "! f(){ \
 CMD='w-del-mcf-param' \
 && if [ $# -lt 1 ]; then git l-echo \"$CMD Error: parameter name is absent.\" 1; git w-list-mcf-param; exit 1;fi \
 && param=${1:-''} \
 && showlog=${2:-on} \
 && oldvalue=$(git w-get-mcf-param $param) \
 && ( t=$(git config --local mcf.$param) && git config --local --unset mcf.$param || : ) \
 && if [ \"$(git config --local --get-regex 'mcf.l-')\" = '' ]; then git config --local --remove-section mcf || : ; fi \
 && if [ $(git l-check-is-on $showlog) != 'on' ]; then return 0; fi \
 && newvalue=$(git w-get-mcf-param \"$param\") \
 && git l-echo \"Old: $param = $oldvalue\" 4 1\
 && git l-echo \"New: $param = $newvalue\" 2 0\
 && git w-list-mcf-param \
;}; f"

# w-list-mcf-param
#  Показывает значения всех l-* параметров для текущего проекта.
  w-list-mcf-param = "! git mcf-list-mcf-param "
mcf-list-mcf-param = "! f() { \
 CMD='w-list-mcf-param' \
 && type=${1:-} \
 && git l-echo \"Current exists parameters:\" 5 0\
 && if [ \"$type\" != 'local' ]; then \
    git l-echo \"Global:\" 6 0 \
 && git l-list-mcf-param --global \
 ; fi \
 && s=$(git config --local --get-regex mcf.l-) \
 && git l-echo \"Local:\" 6 0 \
 && git l-list-mcf-param --local \
;}; f"

# l-checkout-setprev [ $master_new $fix_new $src1_rbranch_new ]
#  Создать временные переменные для работы c хотфикс-ветками.
l-checkout-setprev = "! f(){ \
 CMD='l-checkout-setvar' \
 &&       master_new=${1:-$(git w-get-mcf-param l-master)} \
 && src1_rbranch_new=${2:-$master_new} \
 &&          fix_new=${3:-_fix_${master_new}} \
 && git l-echo-l1 \"$CMD $master_new $fix_new $src1_rbranch_new\" \
 && src1_rbranch=$(git w-get-mcf-param l-src1-rbranch) \
 &&       master=$(git w-get-mcf-param l-master) \
 &&          fix=$(git w-get-mcf-param l-fix) \
 && git w-set-mcf-param l-src1-rbranch \"$src1_rbranch_new\" off \
 && git w-set-mcf-param l-master       \"$master_new\"       off \
 && git w-set-mcf-param l-fix          \"$fix_new\"          off \
 && src1_rbranch_prev=$(git w-get-mcf-param l-prev-src1-rbranch --local 1) \
 &&       master_prev=$(git w-get-mcf-param l-prev-master       --local 1) \
 &&          fix_prev=$(git w-get-mcf-param l-prev-fix          --local 1) \
 && if [ \"$src1_rbranch_prev\" = '' ]; then git w-set-mcf-param l-prev-src1-rbranch \"$src1_rbranch\" off ; fi \
 && if [ \"$master_prev\"       = '' ]; then git w-set-mcf-param l-prev-master       \"$master\"       off ; fi \
 && if [ \"$fix_prev\"          = '' ]; then git w-set-mcf-param l-prev-fix          \"$fix\"          off ; fi \
;}; f"

# w-checkout $master_new [ $src1_rbranch_new $showlog $fix_new ]
#  Построить новую временную схему для выгрузки на удаленный сервер.
#  Используется для создания hotfix веток.
#  Конечная ветка: $fix_new.
  w-checkout = "! git mcf-checkout"
  w-co       = "! git mcf-checkout"
mcf-checkout = "! f(){ \
 CMD='w-checkout' \
 &&        master_new=$1 \
 &&  src1_rbranch_new=${2:-$master_new} \
 &&           fix_new=${3:-_fix_${master_new}} \
 &&           showlog=${4:-on} \
 && git l-echo-l1 \"$CMD $src1_rbranch_new $master_new $fix_new $showlog\" \
 && git l-echo-l2 \"$CMD 1: w-checkout-reset off \" && git w-checkout-reset off \
 && master=$(git w-get-mcf-param l-master) \
 && cfg=$(git w-get-mcf-param l-cfg) \
 && git l-echo-l2 \"$CMD: l-checkout-setprev $master_new $src1_rbranch_new $fix_new\" && git l-checkout-setprev $src1_rbranch_new $master_new $fix_new \
 && if [ \"$(git l-check-exists-branch $master_new)\" = '0' ]; then \
      git l-echo \"git checkout $master_new\" && git checkout -q $master_new ; \
    else \
      git l-echo \"git checkout -b $master_new $master\" && git checkout -b $master_new $master; \
      do_rbranch=$(git w-get-mcf-param l-checkout-autocreate-rbranch); \
      if [ $(git l-check-is-on $do_rbranch) = 'on' ]; then \
        src1=$(git w-get-mcf-param l-src1) \
        && git l-echo \"git push -u ${src1} ${master_new}:${src1_rbranch_new}\" && git push -u ${src1} ${master_new}:${src1_rbranch_new} ; \
      fi \
    fi \
 && git l-echo-l2 \"$CMD 3: git w-rebuild-base $fix_new $cfg $master_new off\" && git w-rebuild-base $fix_new $cfg $master_new off \
 && if [ $(git l-check-is-on $showlog) != 'on' ]; then return 0; fi \
 && git w-list-mcf-param local \
 && git l-showlog $showlog \
;}; f"


# w-checkout-reset
#  Сбросить l-...-prev переменные  и вернуть работу на стандартные ветки
  w-checkout-reset = "! git mcf-checkout-reset"
  w-co-reset       = "! git mcf-checkout-reset"
  w-reset       = "! git mcf-checkout-reset"
mcf-checkout-reset = "! f(){ \
 CMD='w-checkout-reset' \
 && showlog=${1:-on} \
 && src1_rbranch_prev=$(git w-get-mcf-param l-prev-src1-rbranch --local 1) \
 &&       master_prev=$(git w-get-mcf-param l-prev-master       --local 1) \
 &&          fix_prev=$(git w-get-mcf-param l-prev-fix          --local 1) \
 && git l-echo-l1 \"$CMD $showlog\" \
 && if [ \"$src1_rbranch_prev\" != '' ]; then git w-set-mcf-param l-src1-rbranch \"$src1_rbranch_prev\" off && git w-del-mcf-param l-prev-src1-rbranch off; fi \
 && if [ \"$master_prev\"       != '' ]; then git w-set-mcf-param l-master       \"$master_prev\"       off && git w-del-mcf-param l-prev-master       off; fi \
 && if [ \"$fix_prev\"          != '' ]; then git w-set-mcf-param l-fix          \"$fix_prev\"          off && git w-del-mcf-param l-prev-fix          off; fi \
 && fix=$(git w-get-mcf-param l-fix) \
 && cfg=$(git w-get-mcf-param l-cfg) \
 && master=$(git w-get-mcf-param l-master) \
 && git l-echo-l2 \"$CMD 1-1: git w-rebuild-base $fix $cfg $master off\" && git w-rebuild-base $fix $cfg $master off \
 && if [ $(git l-check-is-on $showlog) != 'on' ]; then return 0; fi \
 && git w-list-mcf-param local \
 && git l-showlog $showlog \
;}; f"

#######################################
# git-svn useful (old workflow)
# TODO: Refacroting usiong new workflow
#######################################

pushall      = ! echo "=  pushall"         && git push --all origin
pushallforce = ! echo "=  pushallforce"    && git push --all --force origin

svnlog = !git svn log --oneline -20 | sort
svndcommit   = ! echo "=  git svn dcommit" && git svn dcommit

uploadsvn = "! f(){ \
 fix=${1:-$(git w-get-mcf-param l-fix)} && cfg=${2:-$(git w-get-mcf-param l-cfg)} && master=${3:-$(git w-get-mcf-param l-master)} \
 && echo "=  uploadsvn $fix $cfg $master " \
 && git pushallforce \
 && git updatesvn $fix $cfg $master \
 && git loadsvn $fix $cfg $master \
 && git svndcommit \
 && git updatesvn $fix $cfg $master  \
 && git pushallforce \
 && echo "=====" && git last \
 && echo "=====" && git svnlog ;}; f"

updatesvn = "! f(){ \
 fix=${1:-$(git w-get-mcf-param l-fix)} && cfg=${2:-$(git w-get-mcf-param l-cfg)} && master=${3:-$(git w-get-mcf-param l-master)} \
 && echo "=  updatesvn ${fix} ${cfg} ${master} " \
 && echo "== git checkout $master"    && git checkout -q $master  \
 && echo "== git svn rebase"          && git svn rebase \
 && echo "== git rebase $master $cfg" && git rebase $master $cfg \
 && echo "== git rebase $cfg $fix"    && git rebase $cfg $fix ;}; f"

loadsvn = "! f(){ \
 fix=${1:-$(git w-get-mcf-param l-fix)} && cfg=${2:-$(git w-get-mcf-param l-cfg)} && master=${3:-$(git w-get-mcf-param l-master)} \
 && echo "=  loadsvn $fix $cfg $master " \
 && echo "== git checkout $fix"                   && git checkout -q $fix \
 && echo "== git rebase --onto $master $cfg $fix" && git rebase --onto $master $cfg $fix  \
 && echo "== git checkout $master"                && git checkout -q $master \
 && echo "== git rebase $fix $master"             && git rebase $fix $master ;}; f"

###################
### End ALIASES ###
###################

[mcf]
# Use commands w-(get,set,rm,list)-mcf-param for work with l-* parameters

#Your nickname
	l-nickname = yournick

#  l-debug-level = $level
#    $level :  0  is normal mode. Hide all diagnostic messages.
#    $level :  1  is debug mode 1. Show some diagnostic message in w-* and mcf-* functions.
#    $level :  2  is debug mode 2. Show all diagnostic message in w-* and mcf-* functions.
#  Локальный метод, позволяет управлять выводом сообщений при работе w-* and mcf-* методов.
#  Необходим при отладке методов и при изучении работы команд.
	l-debug-level = 0

# Выполнять или нет копирование локальной ветки $cfg в основной источник $src1 при выполнении w-upload*.
# l-backup-cfg = off - 0|off или 1|on
    l-backup-cfg = off

#  MCF main branches names
    l-fix    = fix
    l-cfg    = cfg
    l-master = master

#  Main source 1
    l-src1         = origin
    l-src1-rbranch = master

#  Additional source 2
    l-src2         = origin
    l-src2-rbranch = master

#  MCF prev branches names
    l-prev-master       = master
    l-prev-src1-rbranch = master
    l-prev-fix          = fix

# Выполнять или нет создание удаленной ветки w-checkout.
# l-checkout-autocreate-rbranch = off - 0|off или 1|on
    l-checkout-autocreate-rbranch = off
