#customize your
#   user.name
#   user.email
#   alias.mynikname
[user]
  name = your_name
  email = your@mail
[alias]
  mynikname = "! f() {          \
    nikname='yournik'            \
    ;echo $nikname              \
  ;}; f"

  myname = "! echo $(git config user.name | tr -d '\n')"
  myallname = "! echo $(git mynikname)'\\|'$(git myname)"

#Check labels in sources. Useful look for nikname, f.e. in comments 
  mycheck = "! f() {                  \
    allname=$(git mynik);             \
    echo Find nikname in sources $allname;                    \
    git grep -nEe \"${allname}\"      \
  ;}; f "

##### Main commands 
  br = branch
  co = checkout
  ci = commit
  amend = commit --amend -C HEAD
  st = status
  rb = rebase
  rbi = rebase -i
  ch = cherry-pick
  type = cat-file -t
  dump = cat-file -p
  unstage = ! git reset HEAD -- $@ 
  sshow = "! f() { git --no-pager show --no-notes --stat --pretty=format:'%C(green)%h %C(yellow)%ad%C(cyan)%d%Creset | %s %C(black bold)[%an]%Creset' --graph --date=short --decorate \"$@\" && echo  ; }; f $@"
  last  = "! f() { git --no-pager log  -20               --pretty=format:'%C(green)%h %C(yellow)%ad%C(cyan)%d%Creset | %s %C(black bold)[%an]%Creset' --graph --date=short --decorate \"$@\" && echo  ; }; f $@"
  hist  = "! f() { git --no-pager log                    --pretty=format:'%C(green)%h %C(yellow)%ad%C(cyan)%d%Creset | %s %C(black bold)[%an]%Creset' --graph --date=short --decorate \"$@\" && echo  ; }; f $@"
  hist2 = "! f() { git --no-pager log                    --pretty=format:'%C(green)%h %C(yellow)%ad%Creset | %s %C(black bold)[%an]%Creset'           --graph --date=short --decorate \"$@\" && echo  ; }; f \"$@\" "
  visual = !gitk --all &
  df = diff
  df0 = diff -U0
  dfc = diff --cached

  #Show log for current user sorted by date
  mylogsort = "! f() { \
    git mylog \"$@\" | sort --key=3,3 -r \
  ;}; f $@"

  #Show log for current user without sorte
  mylog = "! f() { \
    allname=$(git myallname); \
    name=$(git myname); \
    nik=$(git mynikname); \
    echo Log of users: \"'$allname'\" \"'$name'\" \"'$nik'\"; \
    git hist2 \"$@\" --author=\"$allname\" --author=\"=$name\" --author=\"$nik\" \
  ;}; f \"$@\" "
#    git hist2 \"$@\" | grep -i -E \"${allname}\" | sed \"s/\\[${name}\\]//i\" | sed \"s/\\[${nik}\\]//i\" \

##### Useful commands 
  lg    = "! f() { git --no-pager log -p $@ && echo  ; }; f $@"
  lol   = "! f() { git --no-pager log       --graph --decorate --pretty=oneline --abbrev-commit \"$@\"       && echo  ; }; f \"$@\" "
  lola  = "! f() { git --no-pager log --all --graph --decorate --pretty=oneline --abbrev-commit --all \"$@\" && echo  ; }; f \"$@\" "

  # ignored
  # Show files ignored by git:
  ign = ls-files -o -i --exclude-standard
  # to see the list of the ignored files.
  ignored = !git ls-files -v | grep ^[a-z]

  # temporarily ignoring file
  ignore = update-index --assume-unchanged
  unignore = update-index --no-assume-unchanged

  # check merged
  merged = branch --merged
  unmerged = branch --no-merged

  # see gitignore: git gi list
  gi = "!gi() { curl -L -s https://www.gitignore.io/api/$@ ;}; gi"
  ls = ls-files

##### Services commands
fsckclear = "! f(){ \
    echo \"= git fsck\"                                             && git fsck \
    && echo \"= git reflog expire --expire-unreachable=now --all\"  && git reflog expire --expire-unreachable=now --all \
    && echo \"= git gc --prune prunefsck\"                          && git gc --prune=now \
    && echo \"= git fsck\"                                          && git fsck ;}; f"

#######################
##### my worlflow #####
#######################

# Сделать сделать быстро фейковый коммит, например, для тестов.
# Создается фейковый пустой файл.
# Конечная ветка: не меняется.
fakecommit="! f(){ \
 mess=${1:- } \
 && hidelog=${2:-on} \
 && a=_fakefile_.$(basename $PWD).$(date +%Y%m%d_%H%M%S) \
 && [ -z \"$mess\" ] && mess=\"added $a\" || : \
 && touch \"$a\" && git add \"$a\" && git commit -m \"'Fake commit: ${mess}'\" \
 && git checklast $hidelog \
 ; }; f"

# Этот метод можно переопределить в локальном конфиге, если обновлении нужно выполнить дополнительную комманду
# например, чтобы выполнить дополнительную синхронизацию.
addsync = "! f(){ \
 hidelog=${1:-on} \
 && git checklast $hidelog \
 ; }; f"

# Посмотреть последние коммиты текущей ветки, если $hidelog=show|on|''
# Конечная ветка: не меняется.
checklast = "! f(){ \
 hidelog=${1:-''} \
 && [ -z \"$hidelog\" -o \"$hidelog\" = 'on' -o \"$hidelog\" = 'show' ] && (echo '--- Please check ---'; git last) || : \
 ; }; f"

# Сделать временный бекап текущей ветки в репу $dst (origin).
copy2tmp = "! f(){ \
 user=$(git mynikname) \
 && dst=${1:-origin} \
 && hidelog=${2:-on} \
 && cbr=$(git rev-parse --abbrev-ref HEAD) \
 && rbranch=_${user}_${cbr}_tmp \
 && CURDATE=$(date +"%y%m%d_%H%M%S") \
 && MESS=$(echo -n \"Tmp commit of branch '${cbr}'. Date: ${CURDATE}.\") \
 && echo \"=   copy2tmp $dst\" \
 && echo \"==  copy2tmp 1-4:\ngit add --all\"                  && git add --all \
 && echo \"==  copy2tmp 2-4:\ngit commit -am '$MESS'\"         && git commit -m \"${MESS}\" \
 && echo \"==  copy2tmp 3-4:\ngit push -f $dst $cbr:$rbranch\" && git push -f $dst $cbr:$rbranch \
 && echo \"==  copy2tmp 4-4:\ngit reset HEAD~1\"               && git reset HEAD~1 \
 && git checklast $hidelog \
 ; }; f"

# Сделать копию $cfg в репу $dst (origin).
# Конечная ветка: не меняется.
backupcfg = "! f(){ \
 user=$(git mynikname) \
 && cfg=${1:-cfg} \
 && dst=${2:-origin} \
 && hidelog=${3:-on} \
 && rbranch=_${user}_${cfg}_backup \
 && echo \"=   backupcfg $cfg $dst\" \
 && echo \"==  backupcfg 1-1:\ngit push -f $dst $cfg:$rbranch\" && git push -f $dst $cfg:$rbranch \
 && git checklast $hidelog \
 ; }; f"

# Переребейзить $cfg и $fix, Т.е. подготовить ветки к 3-х веточной схемы работы.
# Конечная ветка: $fix.
lupdate = "! f(){ \
 fix=${1:-fix} \
 && cfg=${2:-cfg} \
 && master=${3:-master} \
 && hidelog=${4:-on} \
 && echo \"== lupdate 1-3:\ngit checkout $master\"    && git checkout $master  \
 && echo \"== lupdate 2-3:\ngit rebase $master $cfg\" && git rebase $master $cfg \
 && echo \"== lupdate 3-3:\ngit rebase $cfg $fix\"    && git rebase $cfg $fix \
 && git checklast $hidelog \
 ; }; f"

# Залить новые изменения в ветку $brach (master) из ветки $src_branch ($master) репы $src (origin).
# используя либо rebase (если $rebase=on|rebase|'') или merge.
# Конечная ветка: $branch.
loadfix = "! f(){ \
 branch=${1:-master} \
 && src=${2:-origin} \
 && src_branch=${3:-$master} \
 && rebase=${4:-on} \
 && hidelog=${5:-on} \
 && [ -z \"$rebase\" -o \"$rebase\" = 'on' -o \"$rebase\" = 'rebase' ]     && rebase='true' || rebase='false'  \
 && echo \"== loadfix 1-2:\ngit checkout $branch \"                        && git checkout $branch \
 && echo \"== loadfix 2-2:\ngit pull --rebase=${rebase} $src $src_branch\" && git pull --no-edit --rebase=$rebase $src $src_branch \
 && git checklast $hidelog \
 && echo 'Status: '$? \
 ; }; f"

# Обновить $master из удаленной ветки $src_branch ($master) репы $src (origin) с учетом $rebase (см. loadfix).
# Применить изменения к $cfg и $fix. 
# Выолнить макрос addsync
# Конечная ветка: $fix.
update = "! f(){ \
 fix=${1:-fix} \
 && cfg=${2:-cfg} \
 && master=${3:-master} \
 && src=${4:-origin} \
 && src_branch=${5:-$master} \
 && rebase=${6:-on} \
 && hidelog=${7:-on} \
 && echo \"== update 1-5:\ngit loadfix $src_branch $src $src_branch $rebase\" && git loadfix $src_branch $src $src_branch $rebase off \
 && echo \"== update 2-5:\ngit checkout $master\"                             && git checkout $master \
 && echo \"== update 3-5:\ngit merge $src_branch\"                            && git merge --no-edit $src_branch \
 && echo \"== update 4-5:\ngit lupdate $fix $cfg $master\"                    && git lupdate $fix $cfg $master off \
 && echo \"== update 5-5:\ngit addsync\"                                      && git addsync off\
 && git checklast $hidelog \
 ; }; f"


# Обновить $master из 2х источников
# $src1 (origin) - основное хранилище, $src1_branch ($master) - источник правок в $src1
# $src2 ($src1) - дополнительный источник,  $src2_branch ($src1) - источник правок в $src2
# 1) Сначала обновить $master из удаленной ветки $src1_branch репы $src1 методом rebase.
# 2) Затем обновить $master из удаленной ветки $src2_branch репы $src2 методом merge, 
#    если второй источник отличается от первого
# Конечная ветка: $fix.
update2src = "! f(){ \
 fix=${1:-fix} \
 && cfg=${2:-cfg} \
 && master=${3:-master} \
 && src1=${4:-origin} \
 && src1_branch=${5:-$master} \
 && src2=${6:-$src1} \
 && src2_branch=${7:-$src1_branch} \
 && hidelog=${8:-on} \
 && echo \"== upload2src 1-2:\ngit update $fix $cfg $master $src1 $src1_branch rebase\"  && git update $fix $cfg $master $src1 $src1_branch rebase off \
 && \
if [ \"$src1\" = \"$src2\" -a \"$src1_branch\" = \"$src2_branch\" ] \
; then echo \"== upload2src 2-2: there is not need\" \
; else echo \"== upload2src 2-2:\ngit update $fix $cfg $master $src2 $src2_branch merge\"  && git update $fix $cfg $master $src2 $src2_branch merge  off \
; fi \
 && git checklast $hidelog \
 ; }; f"

# 1) Обновить $master из двух веток (см. update2src), 
#    $src1 (origin) - основное хранилище $src2 ($src1) - дополнительный источник
# 2) Залить изменения из $fix в $master b  Отправить $master в ветку $src1_branch ($master) репы $src1 (origin). 
#    Сделать бекап $cfg.
# Конечная ветка: $fix.
upload = "! f(){ \
 fix=${1:-fix} \
 && cfg=${2:-cfg} \
 && master=${3:-master} \
 && src1=${4:-origin} \
 && src1_branch=${5:-$master} \
 && src2=${6:-$src1} \
 && src2_branch=${7:-$src1_branch} \
 && hidelog=${8:-on} \
 && echo \"== upload 1-2:\ngit update2src $fix $cfg $master $src1 $src1_branch $src2 $src2_branch\" && git update2src $fix $cfg $master $src1 $src1_branch $src2 $src2_branch off \
 && echo \"== upload 2-2:\ngit sendfix $fix $cfg $master $src1 $src1_branch\"                       && git sendfix $fix $cfg $master $src1 $src1_branch off \
 && git checklast $hidelog \
 ; }; f"

# Загрузить свои изменения из ветки $fix в ветку $master, исключая коммиты ветки $cfg.
# Конечная ветка: $fix.
applyfix = "! f(){ \
 fix=${1:-fix} \
 && cfg=${2:-cfg} \
 && master=${3:-master} \
 && hidelog=${4:-on} \
 && echo \"=  applyfix $fix $cfg $master\" \
 && echo \"== applyfix 1-6:\ngit checkout $fix\"                    && git checkout $fix \
 && echo \"== applyfix 2-6:\ngit rebase --onto $master $cfg $fix\"  && git rebase --onto $master $cfg $fix  \
 && echo \"== applyfix 3-6:\ngit checkout $master\"                 && git checkout $master \
 && echo \"== applyfix 4-6:\ngit rebase $fix $master\"              && git rebase $fix $master \
 && echo \"== applyfix 5-6:\ngit rebase $master $cfg\"              && git rebase $master $cfg \
 && echo \"== applyfix 6-6:\ngit rebase $cfg $fix\"                 && git rebase $cfg $fix \
 && git checklast $hidelog \
 ; }; f"

# Залить изменения из $fix в master. 
# Отправить $master в ветку $dst_branch ($master) репы $dst ($origin). 
# Сделать бекап $cfg.
# Конечная ветка: $fix.
sendfix = "! f(){ \
 fix=${1:-fix} \
 && cfg=${2:-cfg} \
 && master=${3:-master} \
 && dst=${4:-origin} \
 && dst_branch=${5:-$master} \
 && hidelog=${6:-on} \
 && echo \"=  sendfix $fix $cfg $master $src $src_branch\" \
 && echo \"== sendfix 1-3:\ngit load $fix $cfg $master\"        && git applyfix $fix $cfg $master off \
 && echo \"== sendfix 2-3:\ngit push $dst $master:$dst_branch\" && git push $dst $master:$dst_branch \
 && echo \"== sendfix 3-3:\ngit backupcfg $cfg $dst\"           && git backupcfg $cfg $dst off \
 && git checklast $hidelog \
 ; }; f"

##########################
### git-svn useful
##########################

pushall      = ! echo "=  pushall"         && git push --all origin
pushallforce = ! echo "=  pushallforce"    && git push --all --force origin


svnlog = !git svn log --oneline -20 | sort
svndcommit   = ! echo "=  git svn dcommit" && git svn dcommit

uploadsvn = "! f(){ \
 fix=${1:-fix} && cfg=${2:-cfg} && master=${3:-master} \
 && echo "=  uploadsvn $fix $cfg $master " \
 && git pushallforce \
 && git updatesvn $fix $cfg $master \
 && git loadsvn $fix $cfg $master \
 && git svndcommit \
 && git updatesvn $fix $cfg $master  \
 && git pushallforce \
 && echo "=====" && git last \
 && echo "=====" && git svnlog ;}; f"

updatesvn = "! f(){ \
 fix=${1:-fix} && cfg=${2:-cfg} && master=${3:-master} \
 && echo "=  updatesvn ${fix} ${cfg} ${master} " \
 && echo "== git checkout $master"       && git checkout $master  \
 && echo "== git svn rebase"       && git svn rebase \
 && echo "== git rebase $master $cfg"  && git rebase $master $cfg \
 && echo "== git rebase $cfg $fix"     && git rebase $cfg $fix ;}; f"

loadsvn = "! f(){ \
 fix=${1:-fix} && cfg=${2:-cfg} && master=${3:-master} \
 && echo "=  loadsvn $fix $cfg $master " \
 && echo "== git checkout $fix"                      && git checkout $fix \
 && echo "== git rebase --onto $master $cfg $fix"  && git rebase --onto $master $cfg $fix  \
 && echo "== git checkout $master"                   && git checkout $master \
 && echo "== git rebase $fix $master"          && git rebase $fix $master ;}; f"

##########################

[commit]
	template = /home/yournik/.gitmessage_template
[color]
	ui = true
	status = true
	diff = true
	branch = true
	interactive = true
	pager = true
	grep = true
[color "log"]
    current = green    
    local = yellow
    remote = green reverse
[color "branch"]
    current = green bold   
    local = yellow
    remote = cyan 
[color "diff"]
    commit = yellow bold 
    meta = normal bold
    frag = magenta bold
    old = red
    new = green
    whitespace = red reverse blink
    plain = normal
    func = normal
[color "status"]
    added = green dim
    changed = cyan
    untracked = yellow
[core]
    whitespace = fix,-indent-with-non-tab,trailing-space,cr-at-eol
    pager = less -FXRS
	editor = mcedit
	autocrlf = false
	safecrlf = false
	eol = native
#    FOR WIN
#    pager = more
#    git config --global core.autocrlf true
#    git config --global core.safecrlf true
[blame]
	data = short
[gui]
	spellingdictionary = en_GB
[merge]
	tool = kdiff3
    guitool = kdiff3
[diff]
	tool = kdiff3
	guitool = kdiff3
[difftool]
	prompt = false
[mergetool]
	prompt = true
[help]
    autocorrect = 1
[http]
	sslverify = false
[push]
    default = upstream