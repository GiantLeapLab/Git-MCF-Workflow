#customize your
#   user.name
#   user.email
#   user.nickname
[user]  
	name = your_name
	email = your@mail
	nickname = yournick
[commit]
#    template = /home/yournick/.gitmessage_template
[color]
    ui = true
    status = true
    diff = true
    branch = true
    interactive = true
    pager = true
    grep = true
[color "log"]
    current = green
    local = yellow
    remote = green reverse
[color "branch"]
    current = green bold
    local = yellow
    remote = cyan
[color "diff"]
    commit = yellow bold
    meta = normal bold
    frag = magenta bold
    old = red
    new = green
    whitespace = red reverse blink
    plain = normal
    func = normal
[color "status"]
    added = green dim
    changed = cyan
    untracked = yellow
[core]
#    edit = mcedit
    whitespace = fix,-indent-with-non-tab,trailing-space,cr-at-eol
    pager = less -FXRS
#    FOR WIN
#    autocrlf = true
	autocrlf = input
    safecrlf = false
    eol = native
#    FOR WIN
#    pager = more
#    git config --global core.autocrlf true
#    git config --global core.safecrlf true
[blame]
    data = short
[gui]
    spellingdictionary = en_GB
[merge]
    tool = kdiff3
    guitool = kdiff3
[diff]
    tool = kdiff3
    guitool = kdiff3
[difftool]
    prompt = false
[mergetool]
    prompt = false
[help]
    autocorrect = 0
[http]
    sslverify = false
[push]
    default = upstream

####################################################################################

#####################
### Start ALIASES ###
#####################
[alias]

###############
# Main commands
###############

br = branch
co = checkout
ci = commit
amend = commit --amend -C HEAD
st = status
rb = rebase
rbi = rebase -i
ch = cherry-pick
unstage = reset HEAD

# diff
df = diff
df0 = diff -U0
dfc = diff --cached
visual = !gitk --all &

# show history and log
sshow = "! f() { git --no-pager show --no-notes --stat --pretty=format:\"%C(green)%h %C(yellow)%ad%C(cyan)%d%Creset | %s %C(black bold)[%an]%Creset\" --graph --date=short --decorate $* && echo  ; }; f "
hist  = "! f() { git --no-pager log                    --pretty=format:\"%C(green)%h %C(yellow)%ad%C(cyan)%d%Creset | %s %C(black bold)[%an]%Creset\" --graph --date=short --decorate $* && echo  ; }; f "
hist2 = "! f() { git --no-pager log                    --pretty=format:\"%C(green)%h %C(yellow)%ad%Creset | %s %C(black bold)[%an]%Creset\"           --graph --date=short --decorate $* && echo  ; }; f "
hist3 = "! f() { git --no-pager log                    --pretty=format:\"%C(green)%h %C(yellow)%ad%Creset | %s %C(cyan)%d %C(black bold)[%an]%Creset\" --graph --date=short --decorate $* && echo  ; }; f "
last  = "! git hist  -20 $* "
last2 = "! git hist2 -20 $* "
last3 = "! git hist3 -20 $* "

###########
# User info
###########

myname    = "! git config user.name"
myemail   = "! git config user.email"
mynickname = "! git config user.nickname"
myallname = "! echo $(git myname)'\\|'$(git mynickname)"

#Check labels in sources. Useful look for nickname, f.e. in comments
mycheck = "! f() { \
 allname=${1:-$(git mynickname)} \
 && git l-echo \"Find '$allname' in sources\" 6  \
 && git --no-pager grep -nEe \"${allname}\" \
;}; f "

#Show log for current user without sorte
mylog = "! f() { \
 allname=$(git myallname); \
 name=$(git myname); \
 nick=$(git mynickname); \
 echo Log of users: \"'$allname'\" \"'$name'\" \"'$nick'\"; \
 git hist2 $* --author=\"$allname\" --author=\"=$name\" --author=\"$nick\" \
;}; f "

#Show log for current user sorted by date
mylogsort = "! f() { \
 git mylog $* | sort -k 3,3 -r \
;}; f"

#################
# Useful commands
#################

# see gitignore rules
gi-list="! git gi list"
# get rules for gitignore: git gi netbeans
gi = "! gi() { curl -L -s https://www.gitignore.io/api/$@ ;}; gi"

show-current-branch-name = "! git cbr"
cbr = rev-parse --abbrev-ref HEAD

# ignored
# Show files ignored by git:
ign = "! git status --ignored --short | awk '/^!!/ { print $2 }'" 
ign-cd = ls-files -o -i --exclude-standard


# temporarily ignoring file
ignore   = update-index --assume-unchanged
unignore = update-index --no-assume-unchanged
# to see the list of the ignored files.
ignored = "!git ls-files -v | grep ^[a-z]"

# check merged
merged   = branch --merged
unmerged = branch --no-merged

# different list and logs
ls = ls-files
lg    = "! f() { git --no-pager log -p $* && echo  ; }; f "
lol   = "! f() { git --no-pager log       --graph --decorate --pretty=oneline --abbrev-commit $*       && echo  ; }; f "
lola  = "! f() { git --no-pager log --all --graph --decorate --pretty=oneline --abbrev-commit --all $* && echo  ; }; f "


type = cat-file -t
dump = cat-file -p

fsckclear = "! f(){ \
 git l-echo \"git fsck\"                                            && git fsck \
 && git l-echo \"git reflog expire --expire-unreachable=now --all\" && git reflog expire --expire-unreachable=now --all \
 && git l-echo \"git gc --prune prunefsck\"                         && git gc --prune=now \
 && git l-echo \"git fsck\"                                         && git fsck \
 && git l-echo \"git gc\"                                           && git gc \
;}; f"

###################
# my workflow
###################

################
# Local commands
################

# Показать сообщение нужным цветом и оттенком
# COLOR={0..7}
#  0-Black(Grey), 1-Red, 2-Green, 3-Brown/Orange(Yellow), 4-Blue,  5-Purple, 6-Cyan, 7-Light Gray(White)
# BRIGHT={0|1|2|4|7|9}
#  0(normal), 1(light), 2(dark), 4(underline), 7(invert) 9(cross)
l-echo = "! f() { \
 MESS=${1:-} \
 && COLOR=${2:-3} \
 && BRIGHT=${3:-1} \
 && COLOR=\"\\033[${BRIGHT};3${COLOR}m\" \
 && NOCOLOR=\"\\033[0m\" \
 && MESS=\"${COLOR}${MESS}${NOCOLOR}\" \
 && [ \"$(uname)\" = 'Linux' ]  && echo \"$MESS\" || echo -e \"$MESS\" \
;}; f"

l-echo-l0 = "! f() { \
 MESS=${1:-} \
 && COLOR=${2:-2} \
 && BRIGHT=${3:-2} \
 && git l-check-debug-level 0 \
 && git l-echo \"= $MESS\" \"$COLOR\" \"$BRIGHT\" \
 || : \
;}; f"

l-echo-l1 = "! f() { \
 MESS=${1:-} \
 && COLOR=${2:-6} \
 && BRIGHT=${3:-2} \
 && git l-check-debug-level 1 \
 && git l-echo \"== $MESS\" \"$COLOR\" \"$BRIGHT\" \
 || : \
;}; f"

# Посмотреть последние коммиты текущей ветки, если $showlog=show|on|''
# Конечная ветка: не меняется.
l-last-check = "! f(){ \
 showlog=${1:-show} \
 && [ -z \"$showlog\" -o \"$showlog\" = 'on' -o \"$showlog\" = 'show' ] && (git l-echo '--- Please check ---' 5; git last) || : \
;}; f"

l-check-debug-level = "! f() { \
 level=${1:-0} \
 && clevel=$(git l-get-mcf-param l-debug-level) \
 && [ \"$level\" -le \"$clevel\" ] && exit 0 || exit 1 \
;}; f"

l-get-mcf-param = "! f() { \
 if [ $# -ne 1 ]; then git l-echo \"Error: l-get-mcf-param has to start with 1 parameter.\" 1 1 ; exit 1; fi \
 && param=$1 \
 && value=$(git config \"mcf.${param}\" ) || git l-echo \"Error: incorrect parameters '$param' when called 'l-get-mcf-param'.\" 1 1 \
 && [ ! -z \"$value\" ] && echo "$value" || exit 1\
; }; f"

#################
# Global commands
#################

#  Все команды имеют основную версию команды (mcf-*) и дополнительную с префиксом (w-*). 
#  Эти команды равнозначны, пока они не переопределены в локальном конфиге. Если необходимо, то переопределять лучше команды w-*, т.к. именно эти команды вызываются в расширенных командах.
#  Команды mcf-* нужно использовать, как команды с поведением по-умолчанию.
#  Расширенные команды выполняют работы с git согласно 3-веточной схемы. Все команды можно переопределять в локальных конфигах, чтобы изменить стандатное поведение. 
#    #Пример
#    #Отключить бекап локального конфига (ветка $cfg) на удаленный сервер для команд w-upload и w-upload2. 
#    > vim /dir/to/project/.git/config 
#      …
#      [alias]
#        w-backup-cfg= "! : "
#  При описании команд ниже запись $param = value  обозначает, что $param c параметром по-умолчанию value.
#  Все команды используют параметры по-умолчанию:
#    $fix = l-fix - имя ветки правок fix в схеме MCF
#    $cfg = l-cfg - имя ветки конфигурации cfg в схеме MCF
#    $master = l-master - имя основной ветки master в схеме MCF
#    $src1 = l-src1 -  имя основного источника
#    $src1_rbranch = l-src1-rbranch - имя удаленной (remote) ветки в основном источнике
#    $src2 = l-src2 - имя вспомогательного источника
#    $src2_rbranch = l-src2-rbranch - имя удаленной (remote) ветки вспомогательного источника
#    $showlog = show - показывать или не показывать (hide|off) log после выполнения команды
#    $rebuild_base = on - делать(on) или не ltkfnm(off) после выполнения команды переустановку базовых веток
#    $method = rebase - метод (rebase|merge), который использовать при получении новых изменений с удаленных (remote) источников

# Локальные константы l-*?, которые находятся в секции [mcf], предназначены, для инициализации параметров команд по-умолчанию, а также для переопределения значений параметров в локальных конфигах.
#   #Пример
#   #Изменить умолчательные имя локальных веток $master -> work и $fix -> dev для текущего проекта.
#   > vim /dir/to/project/.git/config.
#     …
#     [mcf]
#        l-master = work
#        l-fix    = dev
# Также все mcf,w-* команды можно адаптировать для работы с git-svn.
# Далее в примерах мы используем команды с индексом w-*, и они могут быть переопределены в локальных конфигах, так же удобнее и быстрее набирать на клавиатуре.

# w-create-base [ $fix $cfg $master $showlog ]
#  Создать ветки $cfg с базой от $master и $fix с базой от $cfg для работы cо схемой MCF. Если ветки уже были созданы ранее, то будет просто переход на них без изменения базовых коммитов.
#  Конечная ветка: $fix.
  w-create-base = "! git mcf-create-base"
mcf-create-base = "! f(){ \
        fix=${1:-$(git l-get-mcf-param l-fix)} \
 &&     cfg=${2:-$(git l-get-mcf-param l-cfg)} \
 &&  master=${3:-$(git l-get-mcf-param l-master)} \
 && showlog=${4:-show} \
 && git l-echo-l0 \"w-create-base $fix $cfg $master $showlog\" \
 && git l-echo-l1 \"w-create-base 1-3:\";git l-echo \"git checkout $master\" && git checkout $master  \
 && git l-echo-l1 \"w-create-base 2-3:\";git l-echo \"git checkout -b $cfg\" && (git checkout $cfg || git checkout -b $cfg) \
 && git l-echo-l1 \"w-create-base 3-3:\";git l-echo \"git checkout -b $fix\" && (git checkout $fix || git checkout -b $fix) \
 && git l-last-check $showlog \
;}; f"

# w-rebuild-base [ $fix $cfg $master $showlog ]
#  Переустановить базовые коммиты на $master для $cfg и yf и $cfg для $fix, т.е. подготовить для работы cо схемой MCF.
#  Обычно делается всегда после правки конфигурации, или после обновления $master, чтобы внести изменения в базовые ветки.
#  Конечная ветка: $fix.
  w-rebuild-base = "! git mcf-rebuild-base"
mcf-rebuild-base = "! f(){ \
        fix=${1:-$(git l-get-mcf-param l-fix)} \
 &&     cfg=${2:-$(git l-get-mcf-param l-cfg)} \
 &&  master=${3:-$(git l-get-mcf-param l-master)} \
 && showlog=${4:-show} \
 && git l-echo-l0 \"w-rebuild-base $fix $cfg $master $showlog\" \
 && git l-echo-l1 \"w-rebuild-base 1-2:\";git l-echo \"git rebase $master $cfg\" && git rebase $master $cfg \
 && git l-echo-l1 \"w-rebuild-base 1-2:\";git l-echo \"git rebase $cfg $fix\"    && git rebase $cfg $fix \
 && git l-last-check $showlog \
;}; f"

# w-load-fix-from-repo [ $master $src1 $src1_rbranch $method $showlog ]
#  Залить новые изменения в ветку $master из источника $src1 $src1_rbranch используя $method=rebase|merge.
#  Если $method=rebase, то используется git pull --rebase, а иначе git merge.
#  Конечная ветка: $master.
  w-load-fix-from-repo = "! git mcf-load-fix-from-repo"
mcf-load-fix-from-repo = "! f(){ \
          master=${1:-$(git l-get-mcf-param l-master)} \
 &&         src1=${2:-$(git l-get-mcf-param l-src1)} \
 && src1_rbranch=${3:-$(git l-get-mcf-param l-src1-rbranch)} \
 &&       method=${4:-rebase} \
 &&      showlog=${5:-show} \
 && git l-echo-l0 \"w-load-fix-from-repo $master $src1 $src1_rbranch $method $showlog\" \
 && if [ \"$method\" = \"rebase\" ] \
; then \
    git l-echo-l1 \"w-load-fix-from-repo 1-2:\";git l-echo \"git checkout $master\"                   && git checkout $master \
 && git l-echo-l1 \"w-load-fix-from-repo 2-2:\";git l-echo \"git pull --rebase $src1 $src1_rbranch \" && git pull --no-edit --rebase $src1 $src1_rbranch \
; else \
    git l-echo-l1 \"w-load-fix-from-repo 1-3:\";git l-echo \"git fetch $src1 $src1_rbranch \" && git fetch $src1 $src1_rbranch \
 && git l-echo-l1 \"w-load-fix-from-repo 2-3:\";git l-echo \"git checkout $master\"           && git checkout $master \
 && git l-echo-l1 \"w-load-fix-from-repo 3-3:\";git l-echo \"git merge $src1/$src1_rbranch \" && git merge --no-edit $src1/$src1_rbranch \
; fi \
 && git l-last-check $showlog \
;}; f"
# && git l-echo-l1 \"w-load-fix-from-repo 3-3:\";git l-echo \"git merge $src1/$src1_rbranch \" && git merge --no-edit -m \"Merged with $src1/$src1_rbranch\" $param $src1/$src1_rbranch \

# w-update [ $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $rebuild_base $showlog ]
#  Залить обновление в $master из 2-х источников. 
#  Обновить $master из основного источника $src1/$src1_rbranch методом git pull --rebase.
#  Если первый и второй источник одинаковые ($src1 = $src2 && $src1_rbranch = $src2_rbranch), то обновление из второго источника пропускается. 
#  Если первый и второй источник разные, то обновить $master из дополнительного источника $src2/$src2_rbranch методом git merge.
#  Параметр $rebuild_base=on|off указывает, нужно ли после обновления делать переустановку базовых веток. 
#  Конечная ветка: $fix.
  w-update = "! git mcf-update"
mcf-update = "! f(){ \
             fix=${1:-$(git l-get-mcf-param l-fix)} \
 &&          cfg=${2:-$(git l-get-mcf-param l-cfg)} \
 &&       master=${3:-$(git l-get-mcf-param l-master)} \
 &&         src1=${4:-$(git l-get-mcf-param l-src1)} \
 && src1_rbranch=${5:-$(git l-get-mcf-param l-src1-rbranch)} \
 &&         src2=${6:-$(git l-get-mcf-param l-src2)} \
 && src2_rbranch=${7:-$(git l-get-mcf-param l-src2-rbranch)} \
 && rebuild_base=${8:-on} \
 &&      showlog=${9:-show} \
 && git l-echo-l0 \"w-update $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $showlog\" \
 && git l-echo-l1 \"w-update 1-4:\" && git w-load-fix-from-repo $master $src1 $src1_rbranch rebase off \
 && if [ \"$src1\" = \"$src2\" -a \"$src1_rbranch\" = \"$src2_rbranch\" ] \
; then git l-echo-l1 \"w-update 2-4: do not need to update from src2\" \
; else git l-echo-l1 \"w-update 2-4:\" && git w-load-fix-from-repo $master $src2 $src2_rbranch merge off \
; fi \
 && if [ \"$rebuild_base\" = 'on' ] \
; then git l-echo-l1 \"w-update 3-4:\" && git w-rebuild-base $fix $cfg $master off \
; else git l-echo-l1 \"w-update 3-4: do not need to rebuild n\"\
; fi \
 && cbr=$(git show-current-branch-name) \
 && git l-echo-l1 \"w-update 4-4:\" && git w-update-extcmd $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $rebuild_base off \
 && git checkout -q $cbr \
 && git l-last-check $showlog \
;}; f"

# w-update2 [ $src2 $src2_rbranch $fix $cfg $master $src1 $src1_rbranch $rebuild_base $showlog ]
#  Команда аналогична w-update, но другой порядок парaметров.
#  Первые два параметра определяют второй источник, потом указываются остальные параметры или берутся по-умолчанию, как для w-update. 
#  Более удобна при работе с 2-мя источниками, чем w-update, когда используются параметры по-умолчанию, а нужно указать только параметры второго источника.
#  Конечная ветка: $fix.
  w-update2 = "! git mcf-update2"
mcf-update2 = "! f(){ \
            src2=${1:-$(git l-get-mcf-param l-src2)} \
 && src2_rbranch=${2:-$(git l-get-mcf-param l-src2-rbranch)} \
 &&          fix=${3:-$(git l-get-mcf-param l-fix)} \
 &&          cfg=${4:-$(git l-get-mcf-param l-cfg)} \
 &&       master=${5:-$(git l-get-mcf-param l-master)} \
 &&         src1=${6:-$(git l-get-mcf-param l-src1)} \
 && src1_rbranch=${7:-$(git l-get-mcf-param l-src1-rbranch)} \
 && rebuild_base=${8:-on} \
 &&      showlog=${9:-show} \
 && git l-echo-l0 \"w-update2 $src2 $src2_rbranch $fix $cfg $master $src1 $src1_rbranch $rebuild_base $showlog\" \
 && git l-echo-l1 \"w-update2 1-1:\" && git w-update $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $rebuild_base $showlog \
;}; f"

# w-update-extcmd [ $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $rebuild_base $showlog ]
#  Эта команда выполняется после успешного выполнения обновления w-update.
#  Эту команду нужно переопределить в локальном конфиге, чтобы при обновлении можно было выполнить дополнительные действия. 
#  Например, выполнить тесты, дополнительную синхронизацию, дополнительные системные программы и т.п.
#  Конечная ветка: зависит от переопределенной комманды.
#    #Пример: дополнительная синхронизация с 3-м сервером server3
#      vim /dir/to/project/.git/config 
#      …
#      [alias]
#      w-update-extcmd = "! f(){ \
#           git push server3 local_branch:custom_rbranch \
#      ;}; f"
  w-update-extcmd = "! git mcf-update-extcmd"
mcf-update-extcmd = "! f(){ \
             fix=${1:-$(git l-get-mcf-param l-fix)} \
 &&          cfg=${2:-$(git l-get-mcf-param l-cfg)} \
 &&       master=${3:-$(git l-get-mcf-param l-master)} \
 &&         src1=${4:-$(git l-get-mcf-param l-src1)} \
 && src1_rbranch=${5:-$(git l-get-mcf-param l-src1-rbranch)} \
 &&         src2=${6:-$(git l-get-mcf-param l-src2)} \
 && src2_rbranch=${7:-$(git l-get-mcf-param l-src2-rbranch)} \
 &&      showlog=${8:-show} \
 && git l-echo-l0 \"w-update-extcmd $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $showlog\" \
 && git l-last-check $showlog \
;}; f"

# w-upload [ $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $showlog ]
#  Выгружает сделанные изменения из ветки $fix в ветку $master и на сервер $src1.
#  Сначала происходит обновление $master из источников $src1 и $src2 (см. w-update).
#  Затем изменения из $fix заливаются в $master и отправляются в $src1/$src1_rbranch.
#  Конечная ветка: $fix.
  w-upload = "! git mcf-upload"
mcf-upload = "! f(){ \
             fix=${1:-$(git l-get-mcf-param l-fix)} \
 &&          cfg=${2:-$(git l-get-mcf-param l-cfg)} \
 &&       master=${3:-$(git l-get-mcf-param l-master)} \
 &&         src1=${4:-$(git l-get-mcf-param l-src1)} \
 && src1_rbranch=${5:-$(git l-get-mcf-param l-src1-rbranch)} \
 &&         src2=${6:-$(git l-get-mcf-param l-src2)} \
 && src2_rbranch=${7:-$(git l-get-mcf-param l-src2-rbranch)} \
 &&      showlog=${8:-show} \
 && git l-echo-l0 \"w-upload $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $showlog\" \
 && git l-echo-l1 \"w-upload 1-4:\" && git w-update $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch off off \
 && git l-echo-l1 \"w-upload 2-4:\" && git w-rebuild-base $fix $cfg $master off \
 && git l-echo-l1 \"w-upload 3-4:\" && git w-send-fix $fix $cfg $master $src1 $src1_rbranch off \
 && git l-echo-l1 \"w-upload 4-4:\" && git w-backup-cfg $cfg $src1 off \
 && git l-last-check $showlog \
;}; f"
# && git l-echo-l1 \"w-upload 3-5:\" && git w-rebuild-base $fix $cfg $master off \

# w-upload2 [ $src2 $src2_rbranch $fix $cfg $master $src1 $src1_rbranch $showlog ]
#  Команда аналогична w-upload, но другой порядок парaметров.
#  Первые два параметра определяют второй источник, потом указываются остальные параметры или берутся по-умолчанию, как для w-upload. 
#  Более удобна при работе с 2-мя источниками, чем w-upload, если используюся параметры по-умолчанию, а нужно указать только параметры второго источника.
#  Конечная ветка: $fix.
  w-upload2 = "! git mcf-upload2"
mcf-upload2 = "! f(){ \
            src2=${1:-$(git l-get-mcf-param l-src2)} \
 && src2_rbranch=${2:-$(git l-get-mcf-param l-src2-rbranch)} \
 &&          fix=${3:-$(git l-get-mcf-param l-fix)} \
 &&          cfg=${4:-$(git l-get-mcf-param l-cfg)} \
 &&       master=${5:-$(git l-get-mcf-param l-master)} \
 &&         src1=${6:-$(git l-get-mcf-param l-src1)} \
 && src1_rbranch=${7:-$(git l-get-mcf-param l-src1-rbranch)} \
 &&      showlog=${8:-show} \
 && git l-echo-l0 \"w-upload2 $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $showlog\" \
 && git l-echo-l1 \"w-upload2 1-1:\" && git w-upload $fix $cfg $master $src1 $src1_rbranch $src2 $src2_rbranch $showlog \
;}; f"

# w-apply-fix [ $fix $cfg $master $showlog ]
#  Загрузить свои изменения из ветки $fix в ветку $master, исключая коммиты ветки $cfg.
#  Конечная ветка: $fix.
  w-apply-fix = "! git mcf-apply-fix"
mcf-apply-fix = "! f(){ \
        fix=${1:-$(git l-get-mcf-param l-fix)} \
 &&     cfg=${2:-$(git l-get-mcf-param l-cfg)} \
 &&  master=${3:-$(git l-get-mcf-param l-master)} \
 && showlog=${4:-show} \
 && git l-echo-l0 \"w-apply-fix $fix $cfg $master $showlog\" \
 && git l-echo-l1 \"w-apply-fix 1-4:\";git l-echo \"git checkout $fix\"                   && git checkout $fix \
 && git l-echo-l1 \"w-apply-fix 2-4:\";git l-echo \"git rebase --onto $master $cfg $fix\" && git rebase --onto $master $cfg $fix  \
 && git l-echo-l1 \"w-apply-fix 3-4:\";git l-echo \"git rebase $fix $master\"             && git rebase $fix $master \
 && git l-echo-l1 \"w-apply-fix 4-4:\"                                                    && git w-rebuild-base $fix $cfg $master off \
 && git l-last-check $showlog \
;}; f"

# w-send-fix [ $fix $cfg $master $src1 $src1_rbranch $showlog ]
#  Применить изменения (mcf-apply-fix) $fix к $master, и отправить их в $src1/$src1_rbranch.
#  Конечная ветка: $fix.
  w-send-fix = "! git mcf-send-fix"
mcf-send-fix = "! f(){ \
             fix=${1:-$(git l-get-mcf-param l-fix)} \
 &&          cfg=${2:-$(git l-get-mcf-param l-cfg)} \
 &&       master=${3:-$(git l-get-mcf-param l-master)} \
 &&         src1=${4:-$(git l-get-mcf-param l-src1)} \
 && src1_rbranch=${5:-$(git l-get-mcf-param l-src1-rbranch)} \
 &&      showlog=${6:-show} \
 && git l-echo-l0 \"w-send-fix $fix $cfg $master $src1 $src1_rbranch $showlog\" \
 && git l-echo-l1 \"w-send-fix 1-2:\" && git w-apply-fix $fix $cfg $master off \
 && git l-echo-l1 \"w-send-fix 2-2:\";git l-echo \"git push $src1 $master:$src1_rbranch\" && git push $src1 $master:$src1_rbranch \
 && git l-last-check $showlog \
;}; f"

# w-backup-cfg [ $cfg $src1 $showlog ]
#  Сделать бекап ветки конфигурации
#  Отправить копию ветки $cfg в репу $src1 c именем ветки '_{nickname}_{$cfg}_backup'. 
#  Конечная ветка: не меняется.
  w-backup-cfg = "! git mcf-backup-cfg"
mcf-backup-cfg = "! f(){ \
        cfg=${1:-$(git l-get-mcf-param l-cfg)} \
 &&    src1=${2:-$(git l-get-mcf-param l-src1)} \
 && showlog=${3:-show} \
 &&    nick=$(git mynickname) \
 && src1_rbranch=_${nick}_${cfg}_backup \
 && git l-echo-l0 \"w-backup-cfg $cfg $src1 $showlog\" \
 && git l-echo-l1 \"w-backup-cfg 1-1:\";git l-echo \"git push -f $src1 $cfg:$src1_rbranch\" && git push -f $src1 $cfg:$src1_rbranch \
 && git l-last-check $showlog \
;}; f"

# w-copy2tmp [ $src1 $showlog ]
#  Сделать временный бекап состояния текущей ветки.
#  Создается текущее состояние рабочего каталога в репу $src1 с именем ветки '_{nickname}_{name_of_current_branch}_tmp'. При бекапе все несохраненные изменения также отправятся в репу.
#  После завершения бекапа в рабочем катологе состояние файлов будет восстановлено, как до выполнения команды. 
#  Эта операция полезна, если вы не готовы коммитить изменения, но нужно сделать копию текущего состояния.
#  Конечная ветка: не меняется.
  w-copy2tmp = "! git mcf-copy2tmp"
mcf-copy2tmp = "! f(){ \
       src1=${1:-$(git l-get-mcf-param l-src1)} \
 && showlog=${2:-show} \
 &&    nick=$(git mynickname) \
 &&     cbr=$(git show-current-branch-name) \
 && src1_rbranch=_${nick}_${cbr}_tmp \
 && CURDATE=$(date +"%y%m%d_%H%M%S") \
 && MESS=$(echo \"Tmp commit of branch '${cbr}'. Date: ${CURDATE}.\") \
 && TMPFILE='~__REMOVE_THIS_TMP_FILE__' \
 && touch "$TMPFILE" \
 && git l-echo-l0 \"w-copy2tmp $src1 $showlog\" \
 && git l-echo-l1 \"w-copy2tmp 1-4:\";git l-echo \"git add --all\"                   && git add --all \
 && git l-echo-l1 \"w-copy2tmp 2-4:\";git l-echo \"git commit -am '$MESS'\"          && git commit -m \"${MESS}\" \
 && git l-echo-l1 \"w-copy2tmp 3-4:\";git l-echo \"git push -f $src1 $cbr:$src1_rbranch\" && git push -f $src1 $cbr:$src1_rbranch \
 && git l-echo-l1 \"w-copy2tmp 4-4:\";git l-echo \"git reset HEAD~1\"                && git reset HEAD~1 \
 && rm -f "$TMPFILE" \
 && git l-last-check $showlog \
;}; f"

# w-fakecommit [ $mess $showlog ]
#  Создает фейковый коммит.
#  Создается коммит c пустым файлом и коментарием 'Fake: $mess'. По-умолчанию, комментарий - 'Fake: Added _fakefile_...'.
#  Команда используется для тестов и при исследовании git команд. 
#  Конечная ветка: не меняется.
  w-fakecommit = "! git mcf-fakecommit "
mcf-fakecommit = "! f(){ \
       mess=${1:-} \
 && showlog=${2:-show} \
 && a=_fakefile_.$(basename $PWD).$(date +%Y%m%d_%H%M%S) \
 && [ -z \"$mess\" ] && mess=\"Added $a\" || : \
 && sleep 1 && touch \"$a\" && git add \"$a\" --  && git commit -m \"Fake: $mess\" \
 && git l-last-check $showlog \
;}; f"

#######################################
# git-svn useful (old workflow)
# TODO: Refacroting usiong new workflow
#######################################

pushall      = ! echo "=  pushall"         && git push --all origin
pushallforce = ! echo "=  pushallforce"    && git push --all --force origin

svnlog = !git svn log --oneline -20 | sort
svndcommit   = ! echo "=  git svn dcommit" && git svn dcommit

uploadsvn = "! f(){ \
 fix=${1:-$(git l-get-mcf-param l-fix)} && cfg=${2:-$(git l-get-mcf-param l-cfg)} && master=${3:-$(git l-get-mcf-param l-master)} \
 && echo "=  uploadsvn $fix $cfg $master " \
 && git pushallforce \
 && git updatesvn $fix $cfg $master \
 && git loadsvn $fix $cfg $master \
 && git svndcommit \
 && git updatesvn $fix $cfg $master  \
 && git pushallforce \
 && echo "=====" && git last \
 && echo "=====" && git svnlog ;}; f"

updatesvn = "! f(){ \
 fix=${1:-$(git l-get-mcf-param l-fix)} && cfg=${2:-$(git l-get-mcf-param l-cfg)} && master=${3:-$(git l-get-mcf-param l-master)} \
 && echo "=  updatesvn ${fix} ${cfg} ${master} " \
 && echo "== git checkout $master"    && git checkout $master  \
 && echo "== git svn rebase"          && git svn rebase \
 && echo "== git rebase $master $cfg" && git rebase $master $cfg \
 && echo "== git rebase $cfg $fix"    && git rebase $cfg $fix ;}; f"

loadsvn = "! f(){ \
 fix=${1:-$(git l-get-mcf-param l-fix)} && cfg=${2:-$(git l-get-mcf-param l-cfg)} && master=${3:-$(git l-get-mcf-param l-master)} \
 && echo "=  loadsvn $fix $cfg $master " \
 && echo "== git checkout $fix"                   && git checkout $fix \
 && echo "== git rebase --onto $master $cfg $fix" && git rebase --onto $master $cfg $fix  \
 && echo "== git checkout $master"                && git checkout $master \
 && echo "== git rebase $fix $master"             && git rebase $fix $master ;}; f"

###################
### End ALIASES ###
###################

[mcf]
# For get use commnad l-get-mcf-param $nameparam

#  l-debug-level = $level
#    $level : -1  is normal mode. Hide all diagnostic messages.
#    $level :  0  is debug mode 1. Show some diagnostic message in w-* and mcf-* functions.
#    $level :  1  is debug mode 2. Show all diagnostic message in w-* and mcf-* functions.
#  Локальный метод, позволяет управлять выводом сообщений при работе w-* and mcf-* методов.
#  Необходим при отладке методов и при изучении работы команд.
    l-debug-level = -1

#  MCF main branches names
    l-fix = fix
    l-cfg = cfg
    l-master       = master

#  Main source 1
    l-src1         = origin
    l-src1-rbranch = master

#  Additional source 2
    l-src2         = origin
    l-src2-rbranch = master
